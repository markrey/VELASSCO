/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "dem_schema_velassco_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace DEM_Inject {

int _kParticle_typeValues[] = {
  Template_nn_Particle,
  Sphere_Particle
};
const char* _kParticle_typeNames[] = {
  "Template_nn_Particle",
  "Sphere_Particle"
};
const std::map<int, const char*> _Particle_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kParticle_typeValues, _kParticle_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kContact_typeValues[] = {
  Geometry_Contact,
  Particle_Contact
};
const char* _kContact_typeNames[] = {
  "Geometry_Contact",
  "Particle_Contact"
};
const std::map<int, const char*> _Contact_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kContact_typeValues, _kContact_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kParticle_result_property_typeValues[] = {
  Velocity,
  Mass,
  Volume,
  Custom_property_vector,
  Custom_property_scalar
};
const char* _kParticle_result_property_typeNames[] = {
  "Velocity",
  "Mass",
  "Volume",
  "Custom_property_vector",
  "Custom_property_scalar"
};
const std::map<int, const char*> _Particle_result_property_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kParticle_result_property_typeValues, _kParticle_result_property_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


Timestep::~Timestep() throw() {
}


void Timestep::__set_time_value(const double val) {
  this->time_value = val;
}

void Timestep::__set_consists_of(const std::vector<Particle> & val) {
  this->consists_of = val;
}

void Timestep::__set_boundary(const std::vector<FEM_mesh> & val) {
  this->boundary = val;
__isset.boundary = true;
}

void Timestep::__set_has_contact(const std::vector<Contact> & val) {
  this->has_contact = val;
__isset.has_contact = true;
}

const char* Timestep::ascii_fingerprint = "2A59EB011A799963BA93A83AD030DD01";
const uint8_t Timestep::binary_fingerprint[16] = {0x2A,0x59,0xEB,0x01,0x1A,0x79,0x99,0x63,0xBA,0x93,0xA8,0x3A,0xD0,0x30,0xDD,0x01};

uint32_t Timestep::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->time_value);
          this->__isset.time_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->consists_of.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->consists_of.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += this->consists_of[_i4].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.consists_of = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->boundary.clear();
            uint32_t _size5;
            ::apache::thrift::protocol::TType _etype8;
            xfer += iprot->readListBegin(_etype8, _size5);
            this->boundary.resize(_size5);
            uint32_t _i9;
            for (_i9 = 0; _i9 < _size5; ++_i9)
            {
              xfer += this->boundary[_i9].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.boundary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->has_contact.clear();
            uint32_t _size10;
            ::apache::thrift::protocol::TType _etype13;
            xfer += iprot->readListBegin(_etype13, _size10);
            this->has_contact.resize(_size10);
            uint32_t _i14;
            for (_i14 = 0; _i14 < _size10; ++_i14)
            {
              xfer += this->has_contact[_i14].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.has_contact = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Timestep::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("Timestep");

  xfer += oprot->writeFieldBegin("time_value", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->time_value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("consists_of", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->consists_of.size()));
    std::vector<Particle> ::const_iterator _iter15;
    for (_iter15 = this->consists_of.begin(); _iter15 != this->consists_of.end(); ++_iter15)
    {
      xfer += (*_iter15).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.boundary) {
    xfer += oprot->writeFieldBegin("boundary", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->boundary.size()));
      std::vector<FEM_mesh> ::const_iterator _iter16;
      for (_iter16 = this->boundary.begin(); _iter16 != this->boundary.end(); ++_iter16)
      {
        xfer += (*_iter16).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.has_contact) {
    xfer += oprot->writeFieldBegin("has_contact", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->has_contact.size()));
      std::vector<Contact> ::const_iterator _iter17;
      for (_iter17 = this->has_contact.begin(); _iter17 != this->has_contact.end(); ++_iter17)
      {
        xfer += (*_iter17).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(Timestep &a, Timestep &b) {
  using ::std::swap;
  swap(a.time_value, b.time_value);
  swap(a.consists_of, b.consists_of);
  swap(a.boundary, b.boundary);
  swap(a.has_contact, b.has_contact);
  swap(a.__isset, b.__isset);
}

Timestep::Timestep(const Timestep& other18) {
  time_value = other18.time_value;
  consists_of = other18.consists_of;
  boundary = other18.boundary;
  has_contact = other18.has_contact;
  __isset = other18.__isset;
}
Timestep& Timestep::operator=(const Timestep& other19) {
  time_value = other19.time_value;
  consists_of = other19.consists_of;
  boundary = other19.boundary;
  has_contact = other19.has_contact;
  __isset = other19.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const Timestep& obj) {
  using apache::thrift::to_string;
  out << "Timestep(";
  out << "time_value=" << to_string(obj.time_value);
  out << ", " << "consists_of=" << to_string(obj.consists_of);
  out << ", " << "boundary="; (obj.__isset.boundary ? (out << to_string(obj.boundary)) : (out << "<null>"));
  out << ", " << "has_contact="; (obj.__isset.has_contact ? (out << to_string(obj.has_contact)) : (out << "<null>"));
  out << ")";
  return out;
}


Particle::~Particle() throw() {
}


void Particle::__set_id(const int64_t val) {
  this->id = val;
}

void Particle::__set_group(const int64_t val) {
  this->group = val;
}

void Particle::__set_coordinates(const std::vector<double> & val) {
  this->coordinates = val;
}

void Particle::__set_type(const Particle_type val) {
  this->type = val;
}

void Particle::__set_radius(const double val) {
  this->radius = val;
__isset.radius = true;
}

const char* Particle::ascii_fingerprint = "29E241603394A616F41BAAB15842219A";
const uint8_t Particle::binary_fingerprint[16] = {0x29,0xE2,0x41,0x60,0x33,0x94,0xA6,0x16,0xF4,0x1B,0xAA,0xB1,0x58,0x42,0x21,0x9A};

uint32_t Particle::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->group);
          this->__isset.group = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->coordinates.clear();
            uint32_t _size20;
            ::apache::thrift::protocol::TType _etype23;
            xfer += iprot->readListBegin(_etype23, _size20);
            this->coordinates.resize(_size20);
            uint32_t _i24;
            for (_i24 = 0; _i24 < _size20; ++_i24)
            {
              xfer += iprot->readDouble(this->coordinates[_i24]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.coordinates = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast25;
          xfer += iprot->readI32(ecast25);
          this->type = (Particle_type)ecast25;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->radius);
          this->__isset.radius = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Particle::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("Particle");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("group", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->group);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("coordinates", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->coordinates.size()));
    std::vector<double> ::const_iterator _iter26;
    for (_iter26 = this->coordinates.begin(); _iter26 != this->coordinates.end(); ++_iter26)
    {
      xfer += oprot->writeDouble((*_iter26));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.radius) {
    xfer += oprot->writeFieldBegin("radius", ::apache::thrift::protocol::T_DOUBLE, 5);
    xfer += oprot->writeDouble(this->radius);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(Particle &a, Particle &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.group, b.group);
  swap(a.coordinates, b.coordinates);
  swap(a.type, b.type);
  swap(a.radius, b.radius);
  swap(a.__isset, b.__isset);
}

Particle::Particle(const Particle& other27) {
  id = other27.id;
  group = other27.group;
  coordinates = other27.coordinates;
  type = other27.type;
  radius = other27.radius;
  __isset = other27.__isset;
}
Particle& Particle::operator=(const Particle& other28) {
  id = other28.id;
  group = other28.group;
  coordinates = other28.coordinates;
  type = other28.type;
  radius = other28.radius;
  __isset = other28.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const Particle& obj) {
  using apache::thrift::to_string;
  out << "Particle(";
  out << "id=" << to_string(obj.id);
  out << ", " << "group=" << to_string(obj.group);
  out << ", " << "coordinates=" << to_string(obj.coordinates);
  out << ", " << "type=" << to_string(obj.type);
  out << ", " << "radius="; (obj.__isset.radius ? (out << to_string(obj.radius)) : (out << "<null>"));
  out << ")";
  return out;
}


Vertex::~Vertex() throw() {
}


void Vertex::__set_vetex_position(const std::vector<double> & val) {
  this->vetex_position = val;
}

const char* Vertex::ascii_fingerprint = "064FCEFD26A5EE081FFA94C27C1CCF6B";
const uint8_t Vertex::binary_fingerprint[16] = {0x06,0x4F,0xCE,0xFD,0x26,0xA5,0xEE,0x08,0x1F,0xFA,0x94,0xC2,0x7C,0x1C,0xCF,0x6B};

uint32_t Vertex::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->vetex_position.clear();
            uint32_t _size29;
            ::apache::thrift::protocol::TType _etype32;
            xfer += iprot->readListBegin(_etype32, _size29);
            this->vetex_position.resize(_size29);
            uint32_t _i33;
            for (_i33 = 0; _i33 < _size29; ++_i33)
            {
              xfer += iprot->readDouble(this->vetex_position[_i33]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.vetex_position = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Vertex::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("Vertex");

  xfer += oprot->writeFieldBegin("vetex_position", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->vetex_position.size()));
    std::vector<double> ::const_iterator _iter34;
    for (_iter34 = this->vetex_position.begin(); _iter34 != this->vetex_position.end(); ++_iter34)
    {
      xfer += oprot->writeDouble((*_iter34));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(Vertex &a, Vertex &b) {
  using ::std::swap;
  swap(a.vetex_position, b.vetex_position);
  swap(a.__isset, b.__isset);
}

Vertex::Vertex(const Vertex& other35) {
  vetex_position = other35.vetex_position;
  __isset = other35.__isset;
}
Vertex& Vertex::operator=(const Vertex& other36) {
  vetex_position = other36.vetex_position;
  __isset = other36.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const Vertex& obj) {
  using apache::thrift::to_string;
  out << "Vertex(";
  out << "vetex_position=" << to_string(obj.vetex_position);
  out << ")";
  return out;
}


FEM_mesh::~FEM_mesh() throw() {
}


void FEM_mesh::__set_name(const std::string& val) {
  this->name = val;
}

void FEM_mesh::__set_facets(const std::vector<std::vector<Vertex> > & val) {
  this->facets = val;
}

const char* FEM_mesh::ascii_fingerprint = "7FD0123970345074AA6F1AAED6409588";
const uint8_t FEM_mesh::binary_fingerprint[16] = {0x7F,0xD0,0x12,0x39,0x70,0x34,0x50,0x74,0xAA,0x6F,0x1A,0xAE,0xD6,0x40,0x95,0x88};

uint32_t FEM_mesh::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->facets.clear();
            uint32_t _size37;
            ::apache::thrift::protocol::TType _etype40;
            xfer += iprot->readListBegin(_etype40, _size37);
            this->facets.resize(_size37);
            uint32_t _i41;
            for (_i41 = 0; _i41 < _size37; ++_i41)
            {
              {
                this->facets[_i41].clear();
                uint32_t _size42;
                ::apache::thrift::protocol::TType _etype45;
                xfer += iprot->readListBegin(_etype45, _size42);
                this->facets[_i41].resize(_size42);
                uint32_t _i46;
                for (_i46 = 0; _i46 < _size42; ++_i46)
                {
                  xfer += this->facets[_i41][_i46].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.facets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FEM_mesh::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("FEM_mesh");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("facets", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->facets.size()));
    std::vector<std::vector<Vertex> > ::const_iterator _iter47;
    for (_iter47 = this->facets.begin(); _iter47 != this->facets.end(); ++_iter47)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*_iter47).size()));
        std::vector<Vertex> ::const_iterator _iter48;
        for (_iter48 = (*_iter47).begin(); _iter48 != (*_iter47).end(); ++_iter48)
        {
          xfer += (*_iter48).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(FEM_mesh &a, FEM_mesh &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.facets, b.facets);
  swap(a.__isset, b.__isset);
}

FEM_mesh::FEM_mesh(const FEM_mesh& other49) {
  name = other49.name;
  facets = other49.facets;
  __isset = other49.__isset;
}
FEM_mesh& FEM_mesh::operator=(const FEM_mesh& other50) {
  name = other50.name;
  facets = other50.facets;
  __isset = other50.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const FEM_mesh& obj) {
  using apache::thrift::to_string;
  out << "FEM_mesh(";
  out << "name=" << to_string(obj.name);
  out << ", " << "facets=" << to_string(obj.facets);
  out << ")";
  return out;
}


Contact::~Contact() throw() {
}


void Contact::__set_contact_location(const std::vector<double> & val) {
  this->contact_location = val;
}

void Contact::__set_type(const Contact_type val) {
  this->type = val;
}

void Contact::__set_P1_id(const int64_t val) {
  this->P1_id = val;
}

void Contact::__set_P2_id(const int64_t val) {
  this->P2_id = val;
__isset.P2_id = true;
}

void Contact::__set_geometry(const FEM_mesh& val) {
  this->geometry = val;
__isset.geometry = true;
}

const char* Contact::ascii_fingerprint = "07278D2337F857E83ACABB7926188347";
const uint8_t Contact::binary_fingerprint[16] = {0x07,0x27,0x8D,0x23,0x37,0xF8,0x57,0xE8,0x3A,0xCA,0xBB,0x79,0x26,0x18,0x83,0x47};

uint32_t Contact::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->contact_location.clear();
            uint32_t _size51;
            ::apache::thrift::protocol::TType _etype54;
            xfer += iprot->readListBegin(_etype54, _size51);
            this->contact_location.resize(_size51);
            uint32_t _i55;
            for (_i55 = 0; _i55 < _size51; ++_i55)
            {
              xfer += iprot->readDouble(this->contact_location[_i55]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.contact_location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast56;
          xfer += iprot->readI32(ecast56);
          this->type = (Contact_type)ecast56;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->P1_id);
          this->__isset.P1_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->P2_id);
          this->__isset.P2_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->geometry.read(iprot);
          this->__isset.geometry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Contact::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("Contact");

  xfer += oprot->writeFieldBegin("contact_location", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->contact_location.size()));
    std::vector<double> ::const_iterator _iter57;
    for (_iter57 = this->contact_location.begin(); _iter57 != this->contact_location.end(); ++_iter57)
    {
      xfer += oprot->writeDouble((*_iter57));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("P1_id", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->P1_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.P2_id) {
    xfer += oprot->writeFieldBegin("P2_id", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->P2_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.geometry) {
    xfer += oprot->writeFieldBegin("geometry", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->geometry.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(Contact &a, Contact &b) {
  using ::std::swap;
  swap(a.contact_location, b.contact_location);
  swap(a.type, b.type);
  swap(a.P1_id, b.P1_id);
  swap(a.P2_id, b.P2_id);
  swap(a.geometry, b.geometry);
  swap(a.__isset, b.__isset);
}

Contact::Contact(const Contact& other58) {
  contact_location = other58.contact_location;
  type = other58.type;
  P1_id = other58.P1_id;
  P2_id = other58.P2_id;
  geometry = other58.geometry;
  __isset = other58.__isset;
}
Contact& Contact::operator=(const Contact& other59) {
  contact_location = other59.contact_location;
  type = other59.type;
  P1_id = other59.P1_id;
  P2_id = other59.P2_id;
  geometry = other59.geometry;
  __isset = other59.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const Contact& obj) {
  using apache::thrift::to_string;
  out << "Contact(";
  out << "contact_location=" << to_string(obj.contact_location);
  out << ", " << "type=" << to_string(obj.type);
  out << ", " << "P1_id=" << to_string(obj.P1_id);
  out << ", " << "P2_id="; (obj.__isset.P2_id ? (out << to_string(obj.P2_id)) : (out << "<null>"));
  out << ", " << "geometry="; (obj.__isset.geometry ? (out << to_string(obj.geometry)) : (out << "<null>"));
  out << ")";
  return out;
}


Particle_result_property::~Particle_result_property() throw() {
}


void Particle_result_property::__set_type(const Particle_result_property_type val) {
  this->type = val;
}

void Particle_result_property::__set_x_y_z(const std::vector<double> & val) {
  this->x_y_z = val;
__isset.x_y_z = true;
}

void Particle_result_property::__set_scalar(const double val) {
  this->scalar = val;
__isset.scalar = true;
}

void Particle_result_property::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

const char* Particle_result_property::ascii_fingerprint = "687BBE49BDDA3EC26A5ED647216E0BBD";
const uint8_t Particle_result_property::binary_fingerprint[16] = {0x68,0x7B,0xBE,0x49,0xBD,0xDA,0x3E,0xC2,0x6A,0x5E,0xD6,0x47,0x21,0x6E,0x0B,0xBD};

uint32_t Particle_result_property::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast60;
          xfer += iprot->readI32(ecast60);
          this->type = (Particle_result_property_type)ecast60;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->x_y_z.clear();
            uint32_t _size61;
            ::apache::thrift::protocol::TType _etype64;
            xfer += iprot->readListBegin(_etype64, _size61);
            this->x_y_z.resize(_size61);
            uint32_t _i65;
            for (_i65 = 0; _i65 < _size61; ++_i65)
            {
              xfer += iprot->readDouble(this->x_y_z[_i65]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.x_y_z = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->scalar);
          this->__isset.scalar = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Particle_result_property::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("Particle_result_property");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.x_y_z) {
    xfer += oprot->writeFieldBegin("x_y_z", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->x_y_z.size()));
      std::vector<double> ::const_iterator _iter66;
      for (_iter66 = this->x_y_z.begin(); _iter66 != this->x_y_z.end(); ++_iter66)
      {
        xfer += oprot->writeDouble((*_iter66));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.scalar) {
    xfer += oprot->writeFieldBegin("scalar", ::apache::thrift::protocol::T_DOUBLE, 3);
    xfer += oprot->writeDouble(this->scalar);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(Particle_result_property &a, Particle_result_property &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.x_y_z, b.x_y_z);
  swap(a.scalar, b.scalar);
  swap(a.name, b.name);
  swap(a.__isset, b.__isset);
}

Particle_result_property::Particle_result_property(const Particle_result_property& other67) {
  type = other67.type;
  x_y_z = other67.x_y_z;
  scalar = other67.scalar;
  name = other67.name;
  __isset = other67.__isset;
}
Particle_result_property& Particle_result_property::operator=(const Particle_result_property& other68) {
  type = other68.type;
  x_y_z = other68.x_y_z;
  scalar = other68.scalar;
  name = other68.name;
  __isset = other68.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const Particle_result_property& obj) {
  using apache::thrift::to_string;
  out << "Particle_result_property(";
  out << "type=" << to_string(obj.type);
  out << ", " << "x_y_z="; (obj.__isset.x_y_z ? (out << to_string(obj.x_y_z)) : (out << "<null>"));
  out << ", " << "scalar="; (obj.__isset.scalar ? (out << to_string(obj.scalar)) : (out << "<null>"));
  out << ", " << "name="; (obj.__isset.name ? (out << to_string(obj.name)) : (out << "<null>"));
  out << ")";
  return out;
}


Particle_result::~Particle_result() throw() {
}


void Particle_result::__set_valid_for(const Particle& val) {
  this->valid_for = val;
}

void Particle_result::__set_calculated_for(const Timestep& val) {
  this->calculated_for = val;
}

void Particle_result::__set_result_properties(const std::vector<Particle_result_property> & val) {
  this->result_properties = val;
}

const char* Particle_result::ascii_fingerprint = "98185E032F35DC9982F5181989D14793";
const uint8_t Particle_result::binary_fingerprint[16] = {0x98,0x18,0x5E,0x03,0x2F,0x35,0xDC,0x99,0x82,0xF5,0x18,0x19,0x89,0xD1,0x47,0x93};

uint32_t Particle_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->valid_for.read(iprot);
          this->__isset.valid_for = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->calculated_for.read(iprot);
          this->__isset.calculated_for = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->result_properties.clear();
            uint32_t _size69;
            ::apache::thrift::protocol::TType _etype72;
            xfer += iprot->readListBegin(_etype72, _size69);
            this->result_properties.resize(_size69);
            uint32_t _i73;
            for (_i73 = 0; _i73 < _size69; ++_i73)
            {
              xfer += this->result_properties[_i73].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.result_properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Particle_result::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("Particle_result");

  xfer += oprot->writeFieldBegin("valid_for", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->valid_for.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("calculated_for", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->calculated_for.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("result_properties", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->result_properties.size()));
    std::vector<Particle_result_property> ::const_iterator _iter74;
    for (_iter74 = this->result_properties.begin(); _iter74 != this->result_properties.end(); ++_iter74)
    {
      xfer += (*_iter74).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(Particle_result &a, Particle_result &b) {
  using ::std::swap;
  swap(a.valid_for, b.valid_for);
  swap(a.calculated_for, b.calculated_for);
  swap(a.result_properties, b.result_properties);
  swap(a.__isset, b.__isset);
}

Particle_result::Particle_result(const Particle_result& other75) {
  valid_for = other75.valid_for;
  calculated_for = other75.calculated_for;
  result_properties = other75.result_properties;
  __isset = other75.__isset;
}
Particle_result& Particle_result::operator=(const Particle_result& other76) {
  valid_for = other76.valid_for;
  calculated_for = other76.calculated_for;
  result_properties = other76.result_properties;
  __isset = other76.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const Particle_result& obj) {
  using apache::thrift::to_string;
  out << "Particle_result(";
  out << "valid_for=" << to_string(obj.valid_for);
  out << ", " << "calculated_for=" << to_string(obj.calculated_for);
  out << ", " << "result_properties=" << to_string(obj.result_properties);
  out << ")";
  return out;
}


Simulation::~Simulation() throw() {
}


void Simulation::__set_name(const std::string& val) {
  this->name = val;
}

void Simulation::__set_consists_of(const std::vector<Timestep> & val) {
  this->consists_of = val;
}

const char* Simulation::ascii_fingerprint = "2EE0E829DDD9ED980E6761244D24513F";
const uint8_t Simulation::binary_fingerprint[16] = {0x2E,0xE0,0xE8,0x29,0xDD,0xD9,0xED,0x98,0x0E,0x67,0x61,0x24,0x4D,0x24,0x51,0x3F};

uint32_t Simulation::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->consists_of.clear();
            uint32_t _size77;
            ::apache::thrift::protocol::TType _etype80;
            xfer += iprot->readListBegin(_etype80, _size77);
            this->consists_of.resize(_size77);
            uint32_t _i81;
            for (_i81 = 0; _i81 < _size77; ++_i81)
            {
              xfer += this->consists_of[_i81].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.consists_of = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Simulation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("Simulation");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("consists_of", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->consists_of.size()));
    std::vector<Timestep> ::const_iterator _iter82;
    for (_iter82 = this->consists_of.begin(); _iter82 != this->consists_of.end(); ++_iter82)
    {
      xfer += (*_iter82).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(Simulation &a, Simulation &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.consists_of, b.consists_of);
  swap(a.__isset, b.__isset);
}

Simulation::Simulation(const Simulation& other83) {
  name = other83.name;
  consists_of = other83.consists_of;
  __isset = other83.__isset;
}
Simulation& Simulation::operator=(const Simulation& other84) {
  name = other84.name;
  consists_of = other84.consists_of;
  __isset = other84.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const Simulation& obj) {
  using apache::thrift::to_string;
  out << "Simulation(";
  out << "name=" << to_string(obj.name);
  out << ", " << "consists_of=" << to_string(obj.consists_of);
  out << ")";
  return out;
}

} // namespace
