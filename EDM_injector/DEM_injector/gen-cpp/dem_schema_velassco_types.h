/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef dem_schema_velassco_TYPES_H
#define dem_schema_velassco_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace DEM_Inject {

enum Particle_type {
  Template_nn_Particle = 1,
  Sphere_Particle = 2
};

extern const std::map<int, const char*> _Particle_type_VALUES_TO_NAMES;

enum Contact_type {
  Geometry_Contact = 1,
  Particle_Contact = 2
};

extern const std::map<int, const char*> _Contact_type_VALUES_TO_NAMES;

enum Particle_result_property_type {
  Velocity = 1,
  Mass = 2,
  Volume = 3,
  Custom_property_vector = 4,
  Custom_property_scalar = 5
};

extern const std::map<int, const char*> _Particle_result_property_type_VALUES_TO_NAMES;

class Timestep;

class Particle;

class Vertex;

class FEM_mesh;

class Contact;

class Particle_result_property;

class Particle_result;

class Simulation;

typedef struct _Timestep__isset {
  _Timestep__isset() : time_value(false), consists_of(false), boundary(false), has_contact(false) {}
  bool time_value :1;
  bool consists_of :1;
  bool boundary :1;
  bool has_contact :1;
} _Timestep__isset;

class Timestep {
 public:

  static const char* ascii_fingerprint; // = "2A59EB011A799963BA93A83AD030DD01";
  static const uint8_t binary_fingerprint[16]; // = {0x2A,0x59,0xEB,0x01,0x1A,0x79,0x99,0x63,0xBA,0x93,0xA8,0x3A,0xD0,0x30,0xDD,0x01};

  Timestep(const Timestep&);
  Timestep& operator=(const Timestep&);
  Timestep() : time_value(0) {
  }

  virtual ~Timestep() throw();
  double time_value;
  std::vector<Particle>  consists_of;
  std::vector<FEM_mesh>  boundary;
  std::vector<Contact>  has_contact;

  _Timestep__isset __isset;

  void __set_time_value(const double val);

  void __set_consists_of(const std::vector<Particle> & val);

  void __set_boundary(const std::vector<FEM_mesh> & val);

  void __set_has_contact(const std::vector<Contact> & val);

  bool operator == (const Timestep & rhs) const
  {
    if (!(time_value == rhs.time_value))
      return false;
    if (!(consists_of == rhs.consists_of))
      return false;
    if (__isset.boundary != rhs.__isset.boundary)
      return false;
    else if (__isset.boundary && !(boundary == rhs.boundary))
      return false;
    if (__isset.has_contact != rhs.__isset.has_contact)
      return false;
    else if (__isset.has_contact && !(has_contact == rhs.has_contact))
      return false;
    return true;
  }
  bool operator != (const Timestep &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Timestep & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Timestep& obj);
};

void swap(Timestep &a, Timestep &b);

typedef struct _Particle__isset {
  _Particle__isset() : id(false), group(false), coordinates(false), type(false), radius(false) {}
  bool id :1;
  bool group :1;
  bool coordinates :1;
  bool type :1;
  bool radius :1;
} _Particle__isset;

class Particle {
 public:

  static const char* ascii_fingerprint; // = "29E241603394A616F41BAAB15842219A";
  static const uint8_t binary_fingerprint[16]; // = {0x29,0xE2,0x41,0x60,0x33,0x94,0xA6,0x16,0xF4,0x1B,0xAA,0xB1,0x58,0x42,0x21,0x9A};

  Particle(const Particle&);
  Particle& operator=(const Particle&);
  Particle() : id(0), group(0), type((Particle_type)0), radius(0) {
  }

  virtual ~Particle() throw();
  int64_t id;
  int64_t group;
  std::vector<double>  coordinates;
  Particle_type type;
  double radius;

  _Particle__isset __isset;

  void __set_id(const int64_t val);

  void __set_group(const int64_t val);

  void __set_coordinates(const std::vector<double> & val);

  void __set_type(const Particle_type val);

  void __set_radius(const double val);

  bool operator == (const Particle & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(group == rhs.group))
      return false;
    if (!(coordinates == rhs.coordinates))
      return false;
    if (!(type == rhs.type))
      return false;
    if (__isset.radius != rhs.__isset.radius)
      return false;
    else if (__isset.radius && !(radius == rhs.radius))
      return false;
    return true;
  }
  bool operator != (const Particle &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Particle & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Particle& obj);
};

void swap(Particle &a, Particle &b);

typedef struct _Vertex__isset {
  _Vertex__isset() : vetex_position(false) {}
  bool vetex_position :1;
} _Vertex__isset;

class Vertex {
 public:

  static const char* ascii_fingerprint; // = "064FCEFD26A5EE081FFA94C27C1CCF6B";
  static const uint8_t binary_fingerprint[16]; // = {0x06,0x4F,0xCE,0xFD,0x26,0xA5,0xEE,0x08,0x1F,0xFA,0x94,0xC2,0x7C,0x1C,0xCF,0x6B};

  Vertex(const Vertex&);
  Vertex& operator=(const Vertex&);
  Vertex() {
  }

  virtual ~Vertex() throw();
  std::vector<double>  vetex_position;

  _Vertex__isset __isset;

  void __set_vetex_position(const std::vector<double> & val);

  bool operator == (const Vertex & rhs) const
  {
    if (!(vetex_position == rhs.vetex_position))
      return false;
    return true;
  }
  bool operator != (const Vertex &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Vertex & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Vertex& obj);
};

void swap(Vertex &a, Vertex &b);

typedef struct _FEM_mesh__isset {
  _FEM_mesh__isset() : name(false), facets(false) {}
  bool name :1;
  bool facets :1;
} _FEM_mesh__isset;

class FEM_mesh {
 public:

  static const char* ascii_fingerprint; // = "7FD0123970345074AA6F1AAED6409588";
  static const uint8_t binary_fingerprint[16]; // = {0x7F,0xD0,0x12,0x39,0x70,0x34,0x50,0x74,0xAA,0x6F,0x1A,0xAE,0xD6,0x40,0x95,0x88};

  FEM_mesh(const FEM_mesh&);
  FEM_mesh& operator=(const FEM_mesh&);
  FEM_mesh() : name() {
  }

  virtual ~FEM_mesh() throw();
  std::string name;
  std::vector<std::vector<Vertex> >  facets;

  _FEM_mesh__isset __isset;

  void __set_name(const std::string& val);

  void __set_facets(const std::vector<std::vector<Vertex> > & val);

  bool operator == (const FEM_mesh & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(facets == rhs.facets))
      return false;
    return true;
  }
  bool operator != (const FEM_mesh &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FEM_mesh & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const FEM_mesh& obj);
};

void swap(FEM_mesh &a, FEM_mesh &b);

typedef struct _Contact__isset {
  _Contact__isset() : contact_location(false), type(false), P1_id(false), P2_id(false), geometry(false) {}
  bool contact_location :1;
  bool type :1;
  bool P1_id :1;
  bool P2_id :1;
  bool geometry :1;
} _Contact__isset;

class Contact {
 public:

  static const char* ascii_fingerprint; // = "07278D2337F857E83ACABB7926188347";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0x27,0x8D,0x23,0x37,0xF8,0x57,0xE8,0x3A,0xCA,0xBB,0x79,0x26,0x18,0x83,0x47};

  Contact(const Contact&);
  Contact& operator=(const Contact&);
  Contact() : type((Contact_type)0), P1_id(0), P2_id(0) {
  }

  virtual ~Contact() throw();
  std::vector<double>  contact_location;
  Contact_type type;
  int64_t P1_id;
  int64_t P2_id;
  FEM_mesh geometry;

  _Contact__isset __isset;

  void __set_contact_location(const std::vector<double> & val);

  void __set_type(const Contact_type val);

  void __set_P1_id(const int64_t val);

  void __set_P2_id(const int64_t val);

  void __set_geometry(const FEM_mesh& val);

  bool operator == (const Contact & rhs) const
  {
    if (!(contact_location == rhs.contact_location))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(P1_id == rhs.P1_id))
      return false;
    if (__isset.P2_id != rhs.__isset.P2_id)
      return false;
    else if (__isset.P2_id && !(P2_id == rhs.P2_id))
      return false;
    if (__isset.geometry != rhs.__isset.geometry)
      return false;
    else if (__isset.geometry && !(geometry == rhs.geometry))
      return false;
    return true;
  }
  bool operator != (const Contact &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Contact & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Contact& obj);
};

void swap(Contact &a, Contact &b);

typedef struct _Particle_result_property__isset {
  _Particle_result_property__isset() : type(false), x_y_z(false), scalar(false), name(false) {}
  bool type :1;
  bool x_y_z :1;
  bool scalar :1;
  bool name :1;
} _Particle_result_property__isset;

class Particle_result_property {
 public:

  static const char* ascii_fingerprint; // = "687BBE49BDDA3EC26A5ED647216E0BBD";
  static const uint8_t binary_fingerprint[16]; // = {0x68,0x7B,0xBE,0x49,0xBD,0xDA,0x3E,0xC2,0x6A,0x5E,0xD6,0x47,0x21,0x6E,0x0B,0xBD};

  Particle_result_property(const Particle_result_property&);
  Particle_result_property& operator=(const Particle_result_property&);
  Particle_result_property() : type((Particle_result_property_type)0), scalar(0), name() {
  }

  virtual ~Particle_result_property() throw();
  Particle_result_property_type type;
  std::vector<double>  x_y_z;
  double scalar;
  std::string name;

  _Particle_result_property__isset __isset;

  void __set_type(const Particle_result_property_type val);

  void __set_x_y_z(const std::vector<double> & val);

  void __set_scalar(const double val);

  void __set_name(const std::string& val);

  bool operator == (const Particle_result_property & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (__isset.x_y_z != rhs.__isset.x_y_z)
      return false;
    else if (__isset.x_y_z && !(x_y_z == rhs.x_y_z))
      return false;
    if (__isset.scalar != rhs.__isset.scalar)
      return false;
    else if (__isset.scalar && !(scalar == rhs.scalar))
      return false;
    if (__isset.name != rhs.__isset.name)
      return false;
    else if (__isset.name && !(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const Particle_result_property &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Particle_result_property & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Particle_result_property& obj);
};

void swap(Particle_result_property &a, Particle_result_property &b);

typedef struct _Particle_result__isset {
  _Particle_result__isset() : valid_for(false), calculated_for(false), result_properties(false) {}
  bool valid_for :1;
  bool calculated_for :1;
  bool result_properties :1;
} _Particle_result__isset;

class Particle_result {
 public:

  static const char* ascii_fingerprint; // = "98185E032F35DC9982F5181989D14793";
  static const uint8_t binary_fingerprint[16]; // = {0x98,0x18,0x5E,0x03,0x2F,0x35,0xDC,0x99,0x82,0xF5,0x18,0x19,0x89,0xD1,0x47,0x93};

  Particle_result(const Particle_result&);
  Particle_result& operator=(const Particle_result&);
  Particle_result() {
  }

  virtual ~Particle_result() throw();
  Particle valid_for;
  Timestep calculated_for;
  std::vector<Particle_result_property>  result_properties;

  _Particle_result__isset __isset;

  void __set_valid_for(const Particle& val);

  void __set_calculated_for(const Timestep& val);

  void __set_result_properties(const std::vector<Particle_result_property> & val);

  bool operator == (const Particle_result & rhs) const
  {
    if (!(valid_for == rhs.valid_for))
      return false;
    if (!(calculated_for == rhs.calculated_for))
      return false;
    if (!(result_properties == rhs.result_properties))
      return false;
    return true;
  }
  bool operator != (const Particle_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Particle_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Particle_result& obj);
};

void swap(Particle_result &a, Particle_result &b);

typedef struct _Simulation__isset {
  _Simulation__isset() : name(false), consists_of(false) {}
  bool name :1;
  bool consists_of :1;
} _Simulation__isset;

class Simulation {
 public:

  static const char* ascii_fingerprint; // = "2EE0E829DDD9ED980E6761244D24513F";
  static const uint8_t binary_fingerprint[16]; // = {0x2E,0xE0,0xE8,0x29,0xDD,0xD9,0xED,0x98,0x0E,0x67,0x61,0x24,0x4D,0x24,0x51,0x3F};

  Simulation(const Simulation&);
  Simulation& operator=(const Simulation&);
  Simulation() : name() {
  }

  virtual ~Simulation() throw();
  std::string name;
  std::vector<Timestep>  consists_of;

  _Simulation__isset __isset;

  void __set_name(const std::string& val);

  void __set_consists_of(const std::vector<Timestep> & val);

  bool operator == (const Simulation & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(consists_of == rhs.consists_of))
      return false;
    return true;
  }
  bool operator != (const Simulation &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Simulation & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Simulation& obj);
};

void swap(Simulation &a, Simulation &b);

} // namespace

#endif
