#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <time.h>


#include <iostream>
#include <string>
#include <sstream>
#include "Helpers.h"
using namespace std;



// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "velasscoThrift.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/concurrency/ThreadManager.h>
#include <thrift/concurrency/PosixThreadFactory.h>
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/server/TThreadPoolServer.h>
#include <thrift/server/TThreadedServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TTransportUtils.h>
#include <thrift/TToString.h>

using namespace apache::thrift;
using namespace apache::thrift::concurrency;
using namespace apache::thrift::protocol;
using namespace apache::thrift::transport;
using namespace apache::thrift::server;

using boost::shared_ptr;


#include "storageModule.h"

bool askForHelp( const char *txt) {
  return !strcasecmp( txt, "-h") || !strcasecmp( txt, "--h") || !strcasecmp( txt, "-help") || !strcasecmp( txt, "--help");
}

bool thereIsHelpSwitch( int argc, char **argv) {
  // check help switch
  bool ret = false;
  for ( int ia = 1; ia < argc; ia++) {
    if ( askForHelp( argv[ ia])) {
      ret = true;
    }
  }
  return ret;
}

using namespace std;
int main(int argc, char **argv)
{
    srand(time(NULL));
    
    int listen_port = 26266;
    DL_SM_DB_TYPE db_type = DL_SM_DB_HBASE; // DB_EDM
    const char *db_host = "localhost"; // or pez001
    int db_port = 9090; // hbase thrift server

    // begin processing args
    if ( thereIsHelpSwitch( argc, argv)) {
      printf( "Usage: %s [ options] \n", argv[ 0]);
      printf( "  -port port_number         listening port for this Data Layer server (default %d)\n", listen_port);
      printf( "  -db_type { hbase | edm}   type of DB engine to connect to (default %s)\n", getStringFromDBType( db_type));
      printf( "  -db_host hostname         host name of the DB engine Server (default %s)]\n", db_host);
      printf( "  -db_port port_number      port of the DB engine Server (default %d)]\n", db_port);
      return EXIT_FAILURE;
    }

    int processed_args = 1; // first is the program name itself
    for ( int ia = 1; ia < argc; ia++) {
      if ( !strcasecmp( argv[ ia], "-port")) {
	ia++;
	int new_port = listen_port;
	if ( sscanf( argv[ ia], "%d", &new_port) == 1) {
	  listen_port = new_port;
	  processed_args += 2;
	}
      } else if ( !strcasecmp( argv[ ia], "-db_host")) {
	ia++;
	db_host = argv[ ia];
	processed_args += 2;
      } else if ( !strcasecmp( argv[ ia], "-db_port")) {
	ia++;
	int new_port = db_port;
	if ( sscanf( argv[ ia], "%d", &new_port) == 1) {
	  db_port = new_port;
	  processed_args += 2;
	}
      } else if ( !strcasecmp( argv[ ia], "-db_type")) {
	ia++;
	DL_SM_DB_TYPE new_type = getDBTypeFromString( argv[ ia]);
	if ( new_type != DL_SM_DB_UNKNOWN) {
	  db_type = new_type;
	  processed_args += 2;
	}
      } else {
	break;
      }
    }

    if ( processed_args != argc) {
      printf( "Error processing options.\n");
      return EXIT_FAILURE;
    }
    // end processing args
    
    const int workerCount = 64;
    
    boost::shared_ptr<VELaSSCoHandler> handler(new VELaSSCoHandler( db_type, db_host, db_port));
    boost::shared_ptr<TProcessor> processor(new VELaSSCoProcessor(handler));
    boost::shared_ptr<TServerTransport> serverTransport(new TServerSocket(listen_port));
    boost::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
    boost::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());
    
    
    //TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
    
    boost::shared_ptr<ThreadManager> threadManager = ThreadManager::newSimpleThreadManager(workerCount);
    boost::shared_ptr<PosixThreadFactory> threadFactory = boost::shared_ptr<PosixThreadFactory>(new PosixThreadFactory());
    threadManager->threadFactory(threadFactory);
    threadManager->start();
    
    TThreadedServer server(processor,
                           serverTransport,
                           transportFactory,
                           protocolFactory);
    
    DEBUG( "listening on port " << listen_port);

    server.serve();
    return 0;
}

