/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "velassco_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace dli {

int _kElementTypeValues[] = {
  LINE,
  TETRAHEDRA,
  TRIANGLE,
  SPHERE
};
const char* _kElementTypeNames[] = {
  "LINE",
  "TETRAHEDRA",
  "TRIANGLE",
  "SPHERE"
};
const std::map<int, const char*> _ElementType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kElementTypeValues, _kElementTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


Point::~Point() throw() {
}


void Point::__set_x(const double val) {
  this->x = val;
}

void Point::__set_y(const double val) {
  this->y = val;
}

void Point::__set_z(const double val) {
  this->z = val;
}

const char* Point::ascii_fingerprint = "EFFAD640FBA2CA56C50155B2A4545897";
const uint8_t Point::binary_fingerprint[16] = {0xEF,0xFA,0xD6,0x40,0xFB,0xA2,0xCA,0x56,0xC5,0x01,0x55,0xB2,0xA4,0x54,0x58,0x97};

uint32_t Point::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->x);
          this->__isset.x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->y);
          this->__isset.y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->z);
          this->__isset.z = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Point::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("Point");

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("z", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->z);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(Point &a, Point &b) {
  using ::std::swap;
  swap(a.x, b.x);
  swap(a.y, b.y);
  swap(a.z, b.z);
  swap(a.__isset, b.__isset);
}

Point::Point(const Point& other0) {
  x = other0.x;
  y = other0.y;
  z = other0.z;
  __isset = other0.__isset;
}
Point& Point::operator=(const Point& other1) {
  x = other1.x;
  y = other1.y;
  z = other1.z;
  __isset = other1.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const Point& obj) {
  using apache::thrift::to_string;
  out << "Point(";
  out << "x=" << to_string(obj.x);
  out << ", " << "y=" << to_string(obj.y);
  out << ", " << "z=" << to_string(obj.z);
  out << ")";
  return out;
}


Node::~Node() throw() {
}


void Node::__set_id(const int64_t val) {
  this->id = val;
}

void Node::__set_x(const double val) {
  this->x = val;
}

void Node::__set_y(const double val) {
  this->y = val;
}

void Node::__set_z(const double val) {
  this->z = val;
}

const char* Node::ascii_fingerprint = "3BC5E6ABCC6C77829F8D2E02BF3E7711";
const uint8_t Node::binary_fingerprint[16] = {0x3B,0xC5,0xE6,0xAB,0xCC,0x6C,0x77,0x82,0x9F,0x8D,0x2E,0x02,0xBF,0x3E,0x77,0x11};

uint32_t Node::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->x);
          this->__isset.x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->y);
          this->__isset.y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->z);
          this->__isset.z = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Node::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("Node");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("z", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->z);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(Node &a, Node &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.x, b.x);
  swap(a.y, b.y);
  swap(a.z, b.z);
  swap(a.__isset, b.__isset);
}

Node::Node(const Node& other2) {
  id = other2.id;
  x = other2.x;
  y = other2.y;
  z = other2.z;
  __isset = other2.__isset;
}
Node& Node::operator=(const Node& other3) {
  id = other3.id;
  x = other3.x;
  y = other3.y;
  z = other3.z;
  __isset = other3.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const Node& obj) {
  using apache::thrift::to_string;
  out << "Node(";
  out << "id=" << to_string(obj.id);
  out << ", " << "x=" << to_string(obj.x);
  out << ", " << "y=" << to_string(obj.y);
  out << ", " << "z=" << to_string(obj.z);
  out << ")";
  return out;
}


Element::~Element() throw() {
}


void Element::__set_id(const int64_t val) {
  this->id = val;
}

void Element::__set_nodes(const std::vector<Node> & val) {
  this->nodes = val;
}

const char* Element::ascii_fingerprint = "CF06EB28D668C9DD2009463BC083E9B7";
const uint8_t Element::binary_fingerprint[16] = {0xCF,0x06,0xEB,0x28,0xD6,0x68,0xC9,0xDD,0x20,0x09,0x46,0x3B,0xC0,0x83,0xE9,0xB7};

uint32_t Element::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->nodes.clear();
            uint32_t _size4;
            ::apache::thrift::protocol::TType _etype7;
            xfer += iprot->readListBegin(_etype7, _size4);
            this->nodes.resize(_size4);
            uint32_t _i8;
            for (_i8 = 0; _i8 < _size4; ++_i8)
            {
              xfer += this->nodes[_i8].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.nodes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Element::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("Element");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nodes", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->nodes.size()));
    std::vector<Node> ::const_iterator _iter9;
    for (_iter9 = this->nodes.begin(); _iter9 != this->nodes.end(); ++_iter9)
    {
      xfer += (*_iter9).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(Element &a, Element &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.nodes, b.nodes);
  swap(a.__isset, b.__isset);
}

Element::Element(const Element& other10) {
  id = other10.id;
  nodes = other10.nodes;
  __isset = other10.__isset;
}
Element& Element::operator=(const Element& other11) {
  id = other11.id;
  nodes = other11.nodes;
  __isset = other11.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const Element& obj) {
  using apache::thrift::to_string;
  out << "Element(";
  out << "id=" << to_string(obj.id);
  out << ", " << "nodes=" << to_string(obj.nodes);
  out << ")";
  return out;
}


Mesh::~Mesh() throw() {
}


void Mesh::__set_name(const std::string& val) {
  this->name = val;
}

void Mesh::__set_numberOfNodes(const int64_t val) {
  this->numberOfNodes = val;
}

void Mesh::__set_dimension(const int64_t val) {
  this->dimension = val;
}

void Mesh::__set_type(const ElementType val) {
  this->type = val;
}

void Mesh::__set_nodes(const std::vector<Node> & val) {
  this->nodes = val;
}

void Mesh::__set_elements(const std::vector<Element> & val) {
  this->elements = val;
}

const char* Mesh::ascii_fingerprint = "2C6CBE41D033C8504C0B5B732DBA6675";
const uint8_t Mesh::binary_fingerprint[16] = {0x2C,0x6C,0xBE,0x41,0xD0,0x33,0xC8,0x50,0x4C,0x0B,0x5B,0x73,0x2D,0xBA,0x66,0x75};

uint32_t Mesh::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numberOfNodes);
          this->__isset.numberOfNodes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->dimension);
          this->__isset.dimension = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast12;
          xfer += iprot->readI32(ecast12);
          this->type = (ElementType)ecast12;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->nodes.clear();
            uint32_t _size13;
            ::apache::thrift::protocol::TType _etype16;
            xfer += iprot->readListBegin(_etype16, _size13);
            this->nodes.resize(_size13);
            uint32_t _i17;
            for (_i17 = 0; _i17 < _size13; ++_i17)
            {
              xfer += this->nodes[_i17].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.nodes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->elements.clear();
            uint32_t _size18;
            ::apache::thrift::protocol::TType _etype21;
            xfer += iprot->readListBegin(_etype21, _size18);
            this->elements.resize(_size18);
            uint32_t _i22;
            for (_i22 = 0; _i22 < _size18; ++_i22)
            {
              xfer += this->elements[_i22].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.elements = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Mesh::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("Mesh");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numberOfNodes", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->numberOfNodes);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dimension", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->dimension);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nodes", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->nodes.size()));
    std::vector<Node> ::const_iterator _iter23;
    for (_iter23 = this->nodes.begin(); _iter23 != this->nodes.end(); ++_iter23)
    {
      xfer += (*_iter23).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("elements", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->elements.size()));
    std::vector<Element> ::const_iterator _iter24;
    for (_iter24 = this->elements.begin(); _iter24 != this->elements.end(); ++_iter24)
    {
      xfer += (*_iter24).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(Mesh &a, Mesh &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.numberOfNodes, b.numberOfNodes);
  swap(a.dimension, b.dimension);
  swap(a.type, b.type);
  swap(a.nodes, b.nodes);
  swap(a.elements, b.elements);
  swap(a.__isset, b.__isset);
}

Mesh::Mesh(const Mesh& other25) {
  name = other25.name;
  numberOfNodes = other25.numberOfNodes;
  dimension = other25.dimension;
  type = other25.type;
  nodes = other25.nodes;
  elements = other25.elements;
  __isset = other25.__isset;
}
Mesh& Mesh::operator=(const Mesh& other26) {
  name = other26.name;
  numberOfNodes = other26.numberOfNodes;
  dimension = other26.dimension;
  type = other26.type;
  nodes = other26.nodes;
  elements = other26.elements;
  __isset = other26.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const Mesh& obj) {
  using apache::thrift::to_string;
  out << "Mesh(";
  out << "name=" << to_string(obj.name);
  out << ", " << "numberOfNodes=" << to_string(obj.numberOfNodes);
  out << ", " << "dimension=" << to_string(obj.dimension);
  out << ", " << "type=" << to_string(obj.type);
  out << ", " << "nodes=" << to_string(obj.nodes);
  out << ", " << "elements=" << to_string(obj.elements);
  out << ")";
  return out;
}


Triangle::~Triangle() throw() {
}


void Triangle::__set_nodes(const std::vector<Node> & val) {
  this->nodes = val;
}

const char* Triangle::ascii_fingerprint = "71FCB2C6CFFC6D5B287AE7E56012B54C";
const uint8_t Triangle::binary_fingerprint[16] = {0x71,0xFC,0xB2,0xC6,0xCF,0xFC,0x6D,0x5B,0x28,0x7A,0xE7,0xE5,0x60,0x12,0xB5,0x4C};

uint32_t Triangle::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->nodes.clear();
            uint32_t _size27;
            ::apache::thrift::protocol::TType _etype30;
            xfer += iprot->readListBegin(_etype30, _size27);
            this->nodes.resize(_size27);
            uint32_t _i31;
            for (_i31 = 0; _i31 < _size27; ++_i31)
            {
              xfer += this->nodes[_i31].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.nodes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Triangle::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("Triangle");

  xfer += oprot->writeFieldBegin("nodes", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->nodes.size()));
    std::vector<Node> ::const_iterator _iter32;
    for (_iter32 = this->nodes.begin(); _iter32 != this->nodes.end(); ++_iter32)
    {
      xfer += (*_iter32).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(Triangle &a, Triangle &b) {
  using ::std::swap;
  swap(a.nodes, b.nodes);
  swap(a.__isset, b.__isset);
}

Triangle::Triangle(const Triangle& other33) {
  nodes = other33.nodes;
  __isset = other33.__isset;
}
Triangle& Triangle::operator=(const Triangle& other34) {
  nodes = other34.nodes;
  __isset = other34.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const Triangle& obj) {
  using apache::thrift::to_string;
  out << "Triangle(";
  out << "nodes=" << to_string(obj.nodes);
  out << ")";
  return out;
}


rvGetElementOfPointsInSpace::~rvGetElementOfPointsInSpace() throw() {
}


void rvGetElementOfPointsInSpace::__set_status(const std::string& val) {
  this->status = val;
}

void rvGetElementOfPointsInSpace::__set_report(const std::string& val) {
  this->report = val;
}

void rvGetElementOfPointsInSpace::__set_elements(const std::vector<Element> & val) {
  this->elements = val;
}

const char* rvGetElementOfPointsInSpace::ascii_fingerprint = "91424890F8A0A0F92355049756E55722";
const uint8_t rvGetElementOfPointsInSpace::binary_fingerprint[16] = {0x91,0x42,0x48,0x90,0xF8,0xA0,0xA0,0xF9,0x23,0x55,0x04,0x97,0x56,0xE5,0x57,0x22};

uint32_t rvGetElementOfPointsInSpace::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->status);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->report);
          this->__isset.report = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->elements.clear();
            uint32_t _size35;
            ::apache::thrift::protocol::TType _etype38;
            xfer += iprot->readListBegin(_etype38, _size35);
            this->elements.resize(_size35);
            uint32_t _i39;
            for (_i39 = 0; _i39 < _size35; ++_i39)
            {
              xfer += this->elements[_i39].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.elements = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t rvGetElementOfPointsInSpace::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("rvGetElementOfPointsInSpace");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("report", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->report);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("elements", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->elements.size()));
    std::vector<Element> ::const_iterator _iter40;
    for (_iter40 = this->elements.begin(); _iter40 != this->elements.end(); ++_iter40)
    {
      xfer += (*_iter40).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(rvGetElementOfPointsInSpace &a, rvGetElementOfPointsInSpace &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.report, b.report);
  swap(a.elements, b.elements);
  swap(a.__isset, b.__isset);
}

rvGetElementOfPointsInSpace::rvGetElementOfPointsInSpace(const rvGetElementOfPointsInSpace& other41) {
  status = other41.status;
  report = other41.report;
  elements = other41.elements;
  __isset = other41.__isset;
}
rvGetElementOfPointsInSpace& rvGetElementOfPointsInSpace::operator=(const rvGetElementOfPointsInSpace& other42) {
  status = other42.status;
  report = other42.report;
  elements = other42.elements;
  __isset = other42.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const rvGetElementOfPointsInSpace& obj) {
  using apache::thrift::to_string;
  out << "rvGetElementOfPointsInSpace(";
  out << "status=" << to_string(obj.status);
  out << ", " << "report=" << to_string(obj.report);
  out << ", " << "elements=" << to_string(obj.elements);
  out << ")";
  return out;
}


rvGetBoundaryOfLocalMesh::~rvGetBoundaryOfLocalMesh() throw() {
}


void rvGetBoundaryOfLocalMesh::__set_status(const std::string& val) {
  this->status = val;
}

void rvGetBoundaryOfLocalMesh::__set_report(const std::string& val) {
  this->report = val;
}

void rvGetBoundaryOfLocalMesh::__set_elements(const std::vector<Triangle> & val) {
  this->elements = val;
}

const char* rvGetBoundaryOfLocalMesh::ascii_fingerprint = "ACFB939DD19B7D5CCA1CCE5142A90284";
const uint8_t rvGetBoundaryOfLocalMesh::binary_fingerprint[16] = {0xAC,0xFB,0x93,0x9D,0xD1,0x9B,0x7D,0x5C,0xCA,0x1C,0xCE,0x51,0x42,0xA9,0x02,0x84};

uint32_t rvGetBoundaryOfLocalMesh::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->status);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->report);
          this->__isset.report = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->elements.clear();
            uint32_t _size43;
            ::apache::thrift::protocol::TType _etype46;
            xfer += iprot->readListBegin(_etype46, _size43);
            this->elements.resize(_size43);
            uint32_t _i47;
            for (_i47 = 0; _i47 < _size43; ++_i47)
            {
              xfer += this->elements[_i47].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.elements = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t rvGetBoundaryOfLocalMesh::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("rvGetBoundaryOfLocalMesh");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("report", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->report);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("elements", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->elements.size()));
    std::vector<Triangle> ::const_iterator _iter48;
    for (_iter48 = this->elements.begin(); _iter48 != this->elements.end(); ++_iter48)
    {
      xfer += (*_iter48).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(rvGetBoundaryOfLocalMesh &a, rvGetBoundaryOfLocalMesh &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.report, b.report);
  swap(a.elements, b.elements);
  swap(a.__isset, b.__isset);
}

rvGetBoundaryOfLocalMesh::rvGetBoundaryOfLocalMesh(const rvGetBoundaryOfLocalMesh& other49) {
  status = other49.status;
  report = other49.report;
  elements = other49.elements;
  __isset = other49.__isset;
}
rvGetBoundaryOfLocalMesh& rvGetBoundaryOfLocalMesh::operator=(const rvGetBoundaryOfLocalMesh& other50) {
  status = other50.status;
  report = other50.report;
  elements = other50.elements;
  __isset = other50.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const rvGetBoundaryOfLocalMesh& obj) {
  using apache::thrift::to_string;
  out << "rvGetBoundaryOfLocalMesh(";
  out << "status=" << to_string(obj.status);
  out << ", " << "report=" << to_string(obj.report);
  out << ", " << "elements=" << to_string(obj.elements);
  out << ")";
  return out;
}


rvGetResultFromVerticesID_A::~rvGetResultFromVerticesID_A() throw() {
}


void rvGetResultFromVerticesID_A::__set_status(const std::string& val) {
  this->status = val;
}

void rvGetResultFromVerticesID_A::__set_report(const std::string& val) {
  this->report = val;
}

void rvGetResultFromVerticesID_A::__set_nVertices(const int64_t val) {
  this->nVertices = val;
}

void rvGetResultFromVerticesID_A::__set_nValuesPrVertex(const int64_t val) {
  this->nValuesPrVertex = val;
}

void rvGetResultFromVerticesID_A::__set_vertexIDs(const std::vector<int64_t> & val) {
  this->vertexIDs = val;
}

void rvGetResultFromVerticesID_A::__set_resultValues(const std::vector<double> & val) {
  this->resultValues = val;
}

const char* rvGetResultFromVerticesID_A::ascii_fingerprint = "B51FB0E8BE2E9146E9BCED13565E0E5F";
const uint8_t rvGetResultFromVerticesID_A::binary_fingerprint[16] = {0xB5,0x1F,0xB0,0xE8,0xBE,0x2E,0x91,0x46,0xE9,0xBC,0xED,0x13,0x56,0x5E,0x0E,0x5F};

uint32_t rvGetResultFromVerticesID_A::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->status);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->report);
          this->__isset.report = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->nVertices);
          this->__isset.nVertices = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->nValuesPrVertex);
          this->__isset.nValuesPrVertex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->vertexIDs.clear();
            uint32_t _size51;
            ::apache::thrift::protocol::TType _etype54;
            xfer += iprot->readListBegin(_etype54, _size51);
            this->vertexIDs.resize(_size51);
            uint32_t _i55;
            for (_i55 = 0; _i55 < _size51; ++_i55)
            {
              xfer += iprot->readI64(this->vertexIDs[_i55]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.vertexIDs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->resultValues.clear();
            uint32_t _size56;
            ::apache::thrift::protocol::TType _etype59;
            xfer += iprot->readListBegin(_etype59, _size56);
            this->resultValues.resize(_size56);
            uint32_t _i60;
            for (_i60 = 0; _i60 < _size56; ++_i60)
            {
              xfer += iprot->readDouble(this->resultValues[_i60]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.resultValues = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t rvGetResultFromVerticesID_A::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("rvGetResultFromVerticesID_A");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("report", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->report);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nVertices", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->nVertices);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nValuesPrVertex", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->nValuesPrVertex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vertexIDs", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->vertexIDs.size()));
    std::vector<int64_t> ::const_iterator _iter61;
    for (_iter61 = this->vertexIDs.begin(); _iter61 != this->vertexIDs.end(); ++_iter61)
    {
      xfer += oprot->writeI64((*_iter61));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("resultValues", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->resultValues.size()));
    std::vector<double> ::const_iterator _iter62;
    for (_iter62 = this->resultValues.begin(); _iter62 != this->resultValues.end(); ++_iter62)
    {
      xfer += oprot->writeDouble((*_iter62));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(rvGetResultFromVerticesID_A &a, rvGetResultFromVerticesID_A &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.report, b.report);
  swap(a.nVertices, b.nVertices);
  swap(a.nValuesPrVertex, b.nValuesPrVertex);
  swap(a.vertexIDs, b.vertexIDs);
  swap(a.resultValues, b.resultValues);
  swap(a.__isset, b.__isset);
}

rvGetResultFromVerticesID_A::rvGetResultFromVerticesID_A(const rvGetResultFromVerticesID_A& other63) {
  status = other63.status;
  report = other63.report;
  nVertices = other63.nVertices;
  nValuesPrVertex = other63.nValuesPrVertex;
  vertexIDs = other63.vertexIDs;
  resultValues = other63.resultValues;
  __isset = other63.__isset;
}
rvGetResultFromVerticesID_A& rvGetResultFromVerticesID_A::operator=(const rvGetResultFromVerticesID_A& other64) {
  status = other64.status;
  report = other64.report;
  nVertices = other64.nVertices;
  nValuesPrVertex = other64.nValuesPrVertex;
  vertexIDs = other64.vertexIDs;
  resultValues = other64.resultValues;
  __isset = other64.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const rvGetResultFromVerticesID_A& obj) {
  using apache::thrift::to_string;
  out << "rvGetResultFromVerticesID_A(";
  out << "status=" << to_string(obj.status);
  out << ", " << "report=" << to_string(obj.report);
  out << ", " << "nVertices=" << to_string(obj.nVertices);
  out << ", " << "nValuesPrVertex=" << to_string(obj.nValuesPrVertex);
  out << ", " << "vertexIDs=" << to_string(obj.vertexIDs);
  out << ", " << "resultValues=" << to_string(obj.resultValues);
  out << ")";
  return out;
}


VertexResult::~VertexResult() throw() {
}


void VertexResult::__set_vertexID(const int64_t val) {
  this->vertexID = val;
}

void VertexResult::__set_resuls(const std::vector<double> & val) {
  this->resuls = val;
}

const char* VertexResult::ascii_fingerprint = "1CB61EEDEC70E44B3B75F0C0C76D5496";
const uint8_t VertexResult::binary_fingerprint[16] = {0x1C,0xB6,0x1E,0xED,0xEC,0x70,0xE4,0x4B,0x3B,0x75,0xF0,0xC0,0xC7,0x6D,0x54,0x96};

uint32_t VertexResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->vertexID);
          this->__isset.vertexID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->resuls.clear();
            uint32_t _size65;
            ::apache::thrift::protocol::TType _etype68;
            xfer += iprot->readListBegin(_etype68, _size65);
            this->resuls.resize(_size65);
            uint32_t _i69;
            for (_i69 = 0; _i69 < _size65; ++_i69)
            {
              xfer += iprot->readDouble(this->resuls[_i69]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.resuls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t VertexResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("VertexResult");

  xfer += oprot->writeFieldBegin("vertexID", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->vertexID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("resuls", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->resuls.size()));
    std::vector<double> ::const_iterator _iter70;
    for (_iter70 = this->resuls.begin(); _iter70 != this->resuls.end(); ++_iter70)
    {
      xfer += oprot->writeDouble((*_iter70));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(VertexResult &a, VertexResult &b) {
  using ::std::swap;
  swap(a.vertexID, b.vertexID);
  swap(a.resuls, b.resuls);
  swap(a.__isset, b.__isset);
}

VertexResult::VertexResult(const VertexResult& other71) {
  vertexID = other71.vertexID;
  resuls = other71.resuls;
  __isset = other71.__isset;
}
VertexResult& VertexResult::operator=(const VertexResult& other72) {
  vertexID = other72.vertexID;
  resuls = other72.resuls;
  __isset = other72.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const VertexResult& obj) {
  using apache::thrift::to_string;
  out << "VertexResult(";
  out << "vertexID=" << to_string(obj.vertexID);
  out << ", " << "resuls=" << to_string(obj.resuls);
  out << ")";
  return out;
}


rvGetResultFromVerticesID_B::~rvGetResultFromVerticesID_B() throw() {
}


void rvGetResultFromVerticesID_B::__set_status(const std::string& val) {
  this->status = val;
}

void rvGetResultFromVerticesID_B::__set_report(const std::string& val) {
  this->report = val;
}

void rvGetResultFromVerticesID_B::__set_vertexResults(const std::vector<VertexResult> & val) {
  this->vertexResults = val;
}

const char* rvGetResultFromVerticesID_B::ascii_fingerprint = "7D7F6E03D85558681F4AC69C1B4F3FC4";
const uint8_t rvGetResultFromVerticesID_B::binary_fingerprint[16] = {0x7D,0x7F,0x6E,0x03,0xD8,0x55,0x58,0x68,0x1F,0x4A,0xC6,0x9C,0x1B,0x4F,0x3F,0xC4};

uint32_t rvGetResultFromVerticesID_B::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->status);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->report);
          this->__isset.report = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->vertexResults.clear();
            uint32_t _size73;
            ::apache::thrift::protocol::TType _etype76;
            xfer += iprot->readListBegin(_etype76, _size73);
            this->vertexResults.resize(_size73);
            uint32_t _i77;
            for (_i77 = 0; _i77 < _size73; ++_i77)
            {
              xfer += this->vertexResults[_i77].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.vertexResults = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t rvGetResultFromVerticesID_B::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("rvGetResultFromVerticesID_B");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("report", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->report);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vertexResults", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->vertexResults.size()));
    std::vector<VertexResult> ::const_iterator _iter78;
    for (_iter78 = this->vertexResults.begin(); _iter78 != this->vertexResults.end(); ++_iter78)
    {
      xfer += (*_iter78).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(rvGetResultFromVerticesID_B &a, rvGetResultFromVerticesID_B &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.report, b.report);
  swap(a.vertexResults, b.vertexResults);
  swap(a.__isset, b.__isset);
}

rvGetResultFromVerticesID_B::rvGetResultFromVerticesID_B(const rvGetResultFromVerticesID_B& other79) {
  status = other79.status;
  report = other79.report;
  vertexResults = other79.vertexResults;
  __isset = other79.__isset;
}
rvGetResultFromVerticesID_B& rvGetResultFromVerticesID_B::operator=(const rvGetResultFromVerticesID_B& other80) {
  status = other80.status;
  report = other80.report;
  vertexResults = other80.vertexResults;
  __isset = other80.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const rvGetResultFromVerticesID_B& obj) {
  using apache::thrift::to_string;
  out << "rvGetResultFromVerticesID_B(";
  out << "status=" << to_string(obj.status);
  out << ", " << "report=" << to_string(obj.report);
  out << ", " << "vertexResults=" << to_string(obj.vertexResults);
  out << ")";
  return out;
}


ModelInfo::~ModelInfo() throw() {
}


void ModelInfo::__set_name(const std::string& val) {
  this->name = val;
}

void ModelInfo::__set_repository(const std::string& val) {
  this->repository = val;
}

void ModelInfo::__set_owner(const std::string& val) {
  this->owner = val;
}

void ModelInfo::__set_created(const std::string& val) {
  this->created = val;
}

void ModelInfo::__set_accessRights(const std::string& val) {
  this->accessRights = val;
}

void ModelInfo::__set_administrators(const std::string& val) {
  this->administrators = val;
}

void ModelInfo::__set_underlyingSchema(const std::string& val) {
  this->underlyingSchema = val;
}

void ModelInfo::__set_nObjectsInModel(const int64_t val) {
  this->nObjectsInModel = val;
}

void ModelInfo::__set_dataSize(const int64_t val) {
  this->dataSize = val;
}

void ModelInfo::__set_stringEncoding(const std::string& val) {
  this->stringEncoding = val;
}

void ModelInfo::__set_options(const std::string& val) {
  this->options = val;
}

const char* ModelInfo::ascii_fingerprint = "2F09E0B6489C52E1F2AB8A6194159964";
const uint8_t ModelInfo::binary_fingerprint[16] = {0x2F,0x09,0xE0,0xB6,0x48,0x9C,0x52,0xE1,0xF2,0xAB,0x8A,0x61,0x94,0x15,0x99,0x64};

uint32_t ModelInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->repository);
          this->__isset.repository = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->owner);
          this->__isset.owner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->created);
          this->__isset.created = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->accessRights);
          this->__isset.accessRights = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->administrators);
          this->__isset.administrators = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->underlyingSchema);
          this->__isset.underlyingSchema = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->nObjectsInModel);
          this->__isset.nObjectsInModel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->dataSize);
          this->__isset.dataSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->stringEncoding);
          this->__isset.stringEncoding = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->options);
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ModelInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ModelInfo");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("repository", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->repository);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("owner", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->owner);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("created", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->created);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("accessRights", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->accessRights);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("administrators", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->administrators);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("underlyingSchema", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->underlyingSchema);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nObjectsInModel", ::apache::thrift::protocol::T_I64, 8);
  xfer += oprot->writeI64(this->nObjectsInModel);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dataSize", ::apache::thrift::protocol::T_I64, 9);
  xfer += oprot->writeI64(this->dataSize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stringEncoding", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->stringEncoding);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->options);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ModelInfo &a, ModelInfo &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.repository, b.repository);
  swap(a.owner, b.owner);
  swap(a.created, b.created);
  swap(a.accessRights, b.accessRights);
  swap(a.administrators, b.administrators);
  swap(a.underlyingSchema, b.underlyingSchema);
  swap(a.nObjectsInModel, b.nObjectsInModel);
  swap(a.dataSize, b.dataSize);
  swap(a.stringEncoding, b.stringEncoding);
  swap(a.options, b.options);
  swap(a.__isset, b.__isset);
}

ModelInfo::ModelInfo(const ModelInfo& other81) {
  name = other81.name;
  repository = other81.repository;
  owner = other81.owner;
  created = other81.created;
  accessRights = other81.accessRights;
  administrators = other81.administrators;
  underlyingSchema = other81.underlyingSchema;
  nObjectsInModel = other81.nObjectsInModel;
  dataSize = other81.dataSize;
  stringEncoding = other81.stringEncoding;
  options = other81.options;
  __isset = other81.__isset;
}
ModelInfo& ModelInfo::operator=(const ModelInfo& other82) {
  name = other82.name;
  repository = other82.repository;
  owner = other82.owner;
  created = other82.created;
  accessRights = other82.accessRights;
  administrators = other82.administrators;
  underlyingSchema = other82.underlyingSchema;
  nObjectsInModel = other82.nObjectsInModel;
  dataSize = other82.dataSize;
  stringEncoding = other82.stringEncoding;
  options = other82.options;
  __isset = other82.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ModelInfo& obj) {
  using apache::thrift::to_string;
  out << "ModelInfo(";
  out << "name=" << to_string(obj.name);
  out << ", " << "repository=" << to_string(obj.repository);
  out << ", " << "owner=" << to_string(obj.owner);
  out << ", " << "created=" << to_string(obj.created);
  out << ", " << "accessRights=" << to_string(obj.accessRights);
  out << ", " << "administrators=" << to_string(obj.administrators);
  out << ", " << "underlyingSchema=" << to_string(obj.underlyingSchema);
  out << ", " << "nObjectsInModel=" << to_string(obj.nObjectsInModel);
  out << ", " << "dataSize=" << to_string(obj.dataSize);
  out << ", " << "stringEncoding=" << to_string(obj.stringEncoding);
  out << ", " << "options=" << to_string(obj.options);
  out << ")";
  return out;
}


rvGetListOfModels::~rvGetListOfModels() throw() {
}


void rvGetListOfModels::__set_status(const std::string& val) {
  this->status = val;
}

void rvGetListOfModels::__set_report(const std::string& val) {
  this->report = val;
}

void rvGetListOfModels::__set_models(const std::vector<ModelInfo> & val) {
  this->models = val;
}

const char* rvGetListOfModels::ascii_fingerprint = "4E7A4AE3E2EE2E39B94F0D24B82B03EE";
const uint8_t rvGetListOfModels::binary_fingerprint[16] = {0x4E,0x7A,0x4A,0xE3,0xE2,0xEE,0x2E,0x39,0xB9,0x4F,0x0D,0x24,0xB8,0x2B,0x03,0xEE};

uint32_t rvGetListOfModels::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->status);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->report);
          this->__isset.report = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->models.clear();
            uint32_t _size83;
            ::apache::thrift::protocol::TType _etype86;
            xfer += iprot->readListBegin(_etype86, _size83);
            this->models.resize(_size83);
            uint32_t _i87;
            for (_i87 = 0; _i87 < _size83; ++_i87)
            {
              xfer += this->models[_i87].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.models = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t rvGetListOfModels::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("rvGetListOfModels");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("report", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->report);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("models", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->models.size()));
    std::vector<ModelInfo> ::const_iterator _iter88;
    for (_iter88 = this->models.begin(); _iter88 != this->models.end(); ++_iter88)
    {
      xfer += (*_iter88).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(rvGetListOfModels &a, rvGetListOfModels &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.report, b.report);
  swap(a.models, b.models);
  swap(a.__isset, b.__isset);
}

rvGetListOfModels::rvGetListOfModels(const rvGetListOfModels& other89) {
  status = other89.status;
  report = other89.report;
  models = other89.models;
  __isset = other89.__isset;
}
rvGetListOfModels& rvGetListOfModels::operator=(const rvGetListOfModels& other90) {
  status = other90.status;
  report = other90.report;
  models = other90.models;
  __isset = other90.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const rvGetListOfModels& obj) {
  using apache::thrift::to_string;
  out << "rvGetListOfModels(";
  out << "status=" << to_string(obj.status);
  out << ", " << "report=" << to_string(obj.report);
  out << ", " << "models=" << to_string(obj.models);
  out << ")";
  return out;
}

} // namespace
