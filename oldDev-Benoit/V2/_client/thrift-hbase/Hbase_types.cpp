/**
 * Autogenerated by Thrift Compiler (1.0.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Hbase_types.h"

#include <algorithm>

namespace apache { namespace hadoop { namespace hbase { namespace thrift {


TCell::~TCell() throw() {
}


void TCell::__set_value(const Bytes& val) {
  this->value = val;
}

void TCell::__set_timestamp(const int64_t val) {
  this->timestamp = val;
}

const char* TCell::ascii_fingerprint = "1CCCF6FC31CFD1D61BBBB1BAF3590620";
const uint8_t TCell::binary_fingerprint[16] = {0x1C,0xCC,0xF6,0xFC,0x31,0xCF,0xD1,0xD6,0x1B,0xBB,0xB1,0xBA,0xF3,0x59,0x06,0x20};

uint32_t TCell::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TCell::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TCell");

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->timestamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TCell &a, TCell &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.timestamp, b.timestamp);
  swap(a.__isset, b.__isset);
}

TCell::TCell(const TCell& other0) {
  value = other0.value;
  timestamp = other0.timestamp;
  __isset = other0.__isset;
}
TCell& TCell::operator=(const TCell& other1) {
  value = other1.value;
  timestamp = other1.timestamp;
  __isset = other1.__isset;
  return *this;
}

ColumnDescriptor::~ColumnDescriptor() throw() {
}


void ColumnDescriptor::__set_name(const Text& val) {
  this->name = val;
}

void ColumnDescriptor::__set_maxVersions(const int32_t val) {
  this->maxVersions = val;
}

void ColumnDescriptor::__set_compression(const std::string& val) {
  this->compression = val;
}

void ColumnDescriptor::__set_inMemory(const bool val) {
  this->inMemory = val;
}

void ColumnDescriptor::__set_bloomFilterType(const std::string& val) {
  this->bloomFilterType = val;
}

void ColumnDescriptor::__set_bloomFilterVectorSize(const int32_t val) {
  this->bloomFilterVectorSize = val;
}

void ColumnDescriptor::__set_bloomFilterNbHashes(const int32_t val) {
  this->bloomFilterNbHashes = val;
}

void ColumnDescriptor::__set_blockCacheEnabled(const bool val) {
  this->blockCacheEnabled = val;
}

void ColumnDescriptor::__set_timeToLive(const int32_t val) {
  this->timeToLive = val;
}

const char* ColumnDescriptor::ascii_fingerprint = "3B18638852FDF9DD911BC1174265F92E";
const uint8_t ColumnDescriptor::binary_fingerprint[16] = {0x3B,0x18,0x63,0x88,0x52,0xFD,0xF9,0xDD,0x91,0x1B,0xC1,0x17,0x42,0x65,0xF9,0x2E};

uint32_t ColumnDescriptor::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxVersions);
          this->__isset.maxVersions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->compression);
          this->__isset.compression = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->inMemory);
          this->__isset.inMemory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->bloomFilterType);
          this->__isset.bloomFilterType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bloomFilterVectorSize);
          this->__isset.bloomFilterVectorSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bloomFilterNbHashes);
          this->__isset.bloomFilterNbHashes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->blockCacheEnabled);
          this->__isset.blockCacheEnabled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->timeToLive);
          this->__isset.timeToLive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ColumnDescriptor::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ColumnDescriptor");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxVersions", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->maxVersions);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("compression", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->compression);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("inMemory", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->inMemory);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bloomFilterType", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->bloomFilterType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bloomFilterVectorSize", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->bloomFilterVectorSize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bloomFilterNbHashes", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->bloomFilterNbHashes);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("blockCacheEnabled", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->blockCacheEnabled);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timeToLive", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->timeToLive);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ColumnDescriptor &a, ColumnDescriptor &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.maxVersions, b.maxVersions);
  swap(a.compression, b.compression);
  swap(a.inMemory, b.inMemory);
  swap(a.bloomFilterType, b.bloomFilterType);
  swap(a.bloomFilterVectorSize, b.bloomFilterVectorSize);
  swap(a.bloomFilterNbHashes, b.bloomFilterNbHashes);
  swap(a.blockCacheEnabled, b.blockCacheEnabled);
  swap(a.timeToLive, b.timeToLive);
  swap(a.__isset, b.__isset);
}

ColumnDescriptor::ColumnDescriptor(const ColumnDescriptor& other2) {
  name = other2.name;
  maxVersions = other2.maxVersions;
  compression = other2.compression;
  inMemory = other2.inMemory;
  bloomFilterType = other2.bloomFilterType;
  bloomFilterVectorSize = other2.bloomFilterVectorSize;
  bloomFilterNbHashes = other2.bloomFilterNbHashes;
  blockCacheEnabled = other2.blockCacheEnabled;
  timeToLive = other2.timeToLive;
  __isset = other2.__isset;
}
ColumnDescriptor& ColumnDescriptor::operator=(const ColumnDescriptor& other3) {
  name = other3.name;
  maxVersions = other3.maxVersions;
  compression = other3.compression;
  inMemory = other3.inMemory;
  bloomFilterType = other3.bloomFilterType;
  bloomFilterVectorSize = other3.bloomFilterVectorSize;
  bloomFilterNbHashes = other3.bloomFilterNbHashes;
  blockCacheEnabled = other3.blockCacheEnabled;
  timeToLive = other3.timeToLive;
  __isset = other3.__isset;
  return *this;
}

TRegionInfo::~TRegionInfo() throw() {
}


void TRegionInfo::__set_startKey(const Text& val) {
  this->startKey = val;
}

void TRegionInfo::__set_endKey(const Text& val) {
  this->endKey = val;
}

void TRegionInfo::__set_id(const int64_t val) {
  this->id = val;
}

void TRegionInfo::__set_name(const Text& val) {
  this->name = val;
}

void TRegionInfo::__set_version(const int8_t val) {
  this->version = val;
}

const char* TRegionInfo::ascii_fingerprint = "A62468FDF7B959CEE277FA7367D1A4C6";
const uint8_t TRegionInfo::binary_fingerprint[16] = {0xA6,0x24,0x68,0xFD,0xF7,0xB9,0x59,0xCE,0xE2,0x77,0xFA,0x73,0x67,0xD1,0xA4,0xC6};

uint32_t TRegionInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->startKey);
          this->__isset.startKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->endKey);
          this->__isset.endKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRegionInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TRegionInfo");

  xfer += oprot->writeFieldBegin("startKey", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->startKey);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("endKey", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->endKey);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_BYTE, 5);
  xfer += oprot->writeByte(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TRegionInfo &a, TRegionInfo &b) {
  using ::std::swap;
  swap(a.startKey, b.startKey);
  swap(a.endKey, b.endKey);
  swap(a.id, b.id);
  swap(a.name, b.name);
  swap(a.version, b.version);
  swap(a.__isset, b.__isset);
}

TRegionInfo::TRegionInfo(const TRegionInfo& other4) {
  startKey = other4.startKey;
  endKey = other4.endKey;
  id = other4.id;
  name = other4.name;
  version = other4.version;
  __isset = other4.__isset;
}
TRegionInfo& TRegionInfo::operator=(const TRegionInfo& other5) {
  startKey = other5.startKey;
  endKey = other5.endKey;
  id = other5.id;
  name = other5.name;
  version = other5.version;
  __isset = other5.__isset;
  return *this;
}

Mutation::~Mutation() throw() {
}


void Mutation::__set_isDelete(const bool val) {
  this->isDelete = val;
}

void Mutation::__set_column(const Text& val) {
  this->column = val;
}

void Mutation::__set_value(const Text& val) {
  this->value = val;
}

const char* Mutation::ascii_fingerprint = "DC8F62AF23854A1A6849A2A157CCCA65";
const uint8_t Mutation::binary_fingerprint[16] = {0xDC,0x8F,0x62,0xAF,0x23,0x85,0x4A,0x1A,0x68,0x49,0xA2,0xA1,0x57,0xCC,0xCA,0x65};

uint32_t Mutation::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isDelete);
          this->__isset.isDelete = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->column);
          this->__isset.column = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Mutation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("Mutation");

  xfer += oprot->writeFieldBegin("isDelete", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->isDelete);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->column);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(Mutation &a, Mutation &b) {
  using ::std::swap;
  swap(a.isDelete, b.isDelete);
  swap(a.column, b.column);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

Mutation::Mutation(const Mutation& other6) {
  isDelete = other6.isDelete;
  column = other6.column;
  value = other6.value;
  __isset = other6.__isset;
}
Mutation& Mutation::operator=(const Mutation& other7) {
  isDelete = other7.isDelete;
  column = other7.column;
  value = other7.value;
  __isset = other7.__isset;
  return *this;
}

BatchMutation::~BatchMutation() throw() {
}


void BatchMutation::__set_row(const Text& val) {
  this->row = val;
}

void BatchMutation::__set_mutations(const std::vector<Mutation> & val) {
  this->mutations = val;
}

const char* BatchMutation::ascii_fingerprint = "7849EEBF8BB50169F3D2F0DD635BD8ED";
const uint8_t BatchMutation::binary_fingerprint[16] = {0x78,0x49,0xEE,0xBF,0x8B,0xB5,0x01,0x69,0xF3,0xD2,0xF0,0xDD,0x63,0x5B,0xD8,0xED};

uint32_t BatchMutation::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row);
          this->__isset.row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->mutations.clear();
            uint32_t _size8;
            ::apache::thrift::protocol::TType _etype11;
            xfer += iprot->readListBegin(_etype11, _size8);
            this->mutations.resize(_size8);
            uint32_t _i12;
            for (_i12 = 0; _i12 < _size8; ++_i12)
            {
              xfer += this->mutations[_i12].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.mutations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BatchMutation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("BatchMutation");

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->row);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mutations", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->mutations.size()));
    std::vector<Mutation> ::const_iterator _iter13;
    for (_iter13 = this->mutations.begin(); _iter13 != this->mutations.end(); ++_iter13)
    {
      xfer += (*_iter13).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(BatchMutation &a, BatchMutation &b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.mutations, b.mutations);
  swap(a.__isset, b.__isset);
}

BatchMutation::BatchMutation(const BatchMutation& other14) {
  row = other14.row;
  mutations = other14.mutations;
  __isset = other14.__isset;
}
BatchMutation& BatchMutation::operator=(const BatchMutation& other15) {
  row = other15.row;
  mutations = other15.mutations;
  __isset = other15.__isset;
  return *this;
}

TRowResult::~TRowResult() throw() {
}


void TRowResult::__set_row(const Text& val) {
  this->row = val;
}

void TRowResult::__set_columns(const std::map<Text, TCell> & val) {
  this->columns = val;
}

const char* TRowResult::ascii_fingerprint = "AE98EA4F344566FAFE04FA5E5823D1ED";
const uint8_t TRowResult::binary_fingerprint[16] = {0xAE,0x98,0xEA,0x4F,0x34,0x45,0x66,0xFA,0xFE,0x04,0xFA,0x5E,0x58,0x23,0xD1,0xED};

uint32_t TRowResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row);
          this->__isset.row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->columns.clear();
            uint32_t _size16;
            ::apache::thrift::protocol::TType _ktype17;
            ::apache::thrift::protocol::TType _vtype18;
            xfer += iprot->readMapBegin(_ktype17, _vtype18, _size16);
            uint32_t _i20;
            for (_i20 = 0; _i20 < _size16; ++_i20)
            {
              Text _key21;
              xfer += iprot->readBinary(_key21);
              TCell& _val22 = this->columns[_key21];
              xfer += _val22.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRowResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TRowResult");

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->row);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::map<Text, TCell> ::const_iterator _iter23;
    for (_iter23 = this->columns.begin(); _iter23 != this->columns.end(); ++_iter23)
    {
      xfer += oprot->writeBinary(_iter23->first);
      xfer += _iter23->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TRowResult &a, TRowResult &b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.columns, b.columns);
  swap(a.__isset, b.__isset);
}

TRowResult::TRowResult(const TRowResult& other24) {
  row = other24.row;
  columns = other24.columns;
  __isset = other24.__isset;
}
TRowResult& TRowResult::operator=(const TRowResult& other25) {
  row = other25.row;
  columns = other25.columns;
  __isset = other25.__isset;
  return *this;
}

IOError::~IOError() throw() {
}


void IOError::__set_message(const std::string& val) {
  this->message = val;
}

const char* IOError::ascii_fingerprint = "EFB929595D312AC8F305D5A794CFEDA1";
const uint8_t IOError::binary_fingerprint[16] = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

uint32_t IOError::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t IOError::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("IOError");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(IOError &a, IOError &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

IOError::IOError(const IOError& other26) {
  message = other26.message;
  __isset = other26.__isset;
}
IOError& IOError::operator=(const IOError& other27) {
  message = other27.message;
  __isset = other27.__isset;
  return *this;
}

IllegalArgument::~IllegalArgument() throw() {
}


void IllegalArgument::__set_message(const std::string& val) {
  this->message = val;
}

const char* IllegalArgument::ascii_fingerprint = "EFB929595D312AC8F305D5A794CFEDA1";
const uint8_t IllegalArgument::binary_fingerprint[16] = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

uint32_t IllegalArgument::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t IllegalArgument::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("IllegalArgument");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(IllegalArgument &a, IllegalArgument &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

IllegalArgument::IllegalArgument(const IllegalArgument& other28) {
  message = other28.message;
  __isset = other28.__isset;
}
IllegalArgument& IllegalArgument::operator=(const IllegalArgument& other29) {
  message = other29.message;
  __isset = other29.__isset;
  return *this;
}

AlreadyExists::~AlreadyExists() throw() {
}


void AlreadyExists::__set_message(const std::string& val) {
  this->message = val;
}

const char* AlreadyExists::ascii_fingerprint = "EFB929595D312AC8F305D5A794CFEDA1";
const uint8_t AlreadyExists::binary_fingerprint[16] = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

uint32_t AlreadyExists::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AlreadyExists::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("AlreadyExists");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(AlreadyExists &a, AlreadyExists &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

AlreadyExists::AlreadyExists(const AlreadyExists& other30) {
  message = other30.message;
  __isset = other30.__isset;
}
AlreadyExists& AlreadyExists::operator=(const AlreadyExists& other31) {
  message = other31.message;
  __isset = other31.__isset;
  return *this;
}
}}}} // namespace
