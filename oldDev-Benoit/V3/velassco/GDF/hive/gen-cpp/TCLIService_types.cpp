/**
 * Autogenerated by Thrift Compiler (1.0.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "TCLIService_types.h"

#include <algorithm>

namespace apache { namespace hive { namespace service { namespace cli { namespace thrift {

int _kTProtocolVersionValues[] = {
  TProtocolVersion::HIVE_CLI_SERVICE_PROTOCOL_V1,
  TProtocolVersion::HIVE_CLI_SERVICE_PROTOCOL_V2,
  TProtocolVersion::HIVE_CLI_SERVICE_PROTOCOL_V3,
  TProtocolVersion::HIVE_CLI_SERVICE_PROTOCOL_V4,
  TProtocolVersion::HIVE_CLI_SERVICE_PROTOCOL_V5
};
const char* _kTProtocolVersionNames[] = {
  "HIVE_CLI_SERVICE_PROTOCOL_V1",
  "HIVE_CLI_SERVICE_PROTOCOL_V2",
  "HIVE_CLI_SERVICE_PROTOCOL_V3",
  "HIVE_CLI_SERVICE_PROTOCOL_V4",
  "HIVE_CLI_SERVICE_PROTOCOL_V5"
};
const std::map<int, const char*> _TProtocolVersion_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kTProtocolVersionValues, _kTProtocolVersionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTTypeIdValues[] = {
  TTypeId::BOOLEAN_TYPE,
  TTypeId::TINYINT_TYPE,
  TTypeId::SMALLINT_TYPE,
  TTypeId::INT_TYPE,
  TTypeId::BIGINT_TYPE,
  TTypeId::FLOAT_TYPE,
  TTypeId::DOUBLE_TYPE,
  TTypeId::STRING_TYPE,
  TTypeId::TIMESTAMP_TYPE,
  TTypeId::BINARY_TYPE,
  TTypeId::ARRAY_TYPE,
  TTypeId::MAP_TYPE,
  TTypeId::STRUCT_TYPE,
  TTypeId::UNION_TYPE,
  TTypeId::USER_DEFINED_TYPE,
  TTypeId::DECIMAL_TYPE,
  TTypeId::NULL_TYPE,
  TTypeId::DATE_TYPE,
  TTypeId::VARCHAR_TYPE,
  TTypeId::CHAR_TYPE
};
const char* _kTTypeIdNames[] = {
  "BOOLEAN_TYPE",
  "TINYINT_TYPE",
  "SMALLINT_TYPE",
  "INT_TYPE",
  "BIGINT_TYPE",
  "FLOAT_TYPE",
  "DOUBLE_TYPE",
  "STRING_TYPE",
  "TIMESTAMP_TYPE",
  "BINARY_TYPE",
  "ARRAY_TYPE",
  "MAP_TYPE",
  "STRUCT_TYPE",
  "UNION_TYPE",
  "USER_DEFINED_TYPE",
  "DECIMAL_TYPE",
  "NULL_TYPE",
  "DATE_TYPE",
  "VARCHAR_TYPE",
  "CHAR_TYPE"
};
const std::map<int, const char*> _TTypeId_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(20, _kTTypeIdValues, _kTTypeIdNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTStatusCodeValues[] = {
  TStatusCode::SUCCESS_STATUS,
  TStatusCode::SUCCESS_WITH_INFO_STATUS,
  TStatusCode::STILL_EXECUTING_STATUS,
  TStatusCode::ERROR_STATUS,
  TStatusCode::INVALID_HANDLE_STATUS
};
const char* _kTStatusCodeNames[] = {
  "SUCCESS_STATUS",
  "SUCCESS_WITH_INFO_STATUS",
  "STILL_EXECUTING_STATUS",
  "ERROR_STATUS",
  "INVALID_HANDLE_STATUS"
};
const std::map<int, const char*> _TStatusCode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kTStatusCodeValues, _kTStatusCodeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTOperationStateValues[] = {
  TOperationState::INITIALIZED_STATE,
  TOperationState::RUNNING_STATE,
  TOperationState::FINISHED_STATE,
  TOperationState::CANCELED_STATE,
  TOperationState::CLOSED_STATE,
  TOperationState::ERROR_STATE,
  TOperationState::UKNOWN_STATE,
  TOperationState::PENDING_STATE
};
const char* _kTOperationStateNames[] = {
  "INITIALIZED_STATE",
  "RUNNING_STATE",
  "FINISHED_STATE",
  "CANCELED_STATE",
  "CLOSED_STATE",
  "ERROR_STATE",
  "UKNOWN_STATE",
  "PENDING_STATE"
};
const std::map<int, const char*> _TOperationState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _kTOperationStateValues, _kTOperationStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTOperationTypeValues[] = {
  TOperationType::EXECUTE_STATEMENT,
  TOperationType::GET_TYPE_INFO,
  TOperationType::GET_CATALOGS,
  TOperationType::GET_SCHEMAS,
  TOperationType::GET_TABLES,
  TOperationType::GET_TABLE_TYPES,
  TOperationType::GET_COLUMNS,
  TOperationType::GET_FUNCTIONS,
  TOperationType::UNKNOWN
};
const char* _kTOperationTypeNames[] = {
  "EXECUTE_STATEMENT",
  "GET_TYPE_INFO",
  "GET_CATALOGS",
  "GET_SCHEMAS",
  "GET_TABLES",
  "GET_TABLE_TYPES",
  "GET_COLUMNS",
  "GET_FUNCTIONS",
  "UNKNOWN"
};
const std::map<int, const char*> _TOperationType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(9, _kTOperationTypeValues, _kTOperationTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTGetInfoTypeValues[] = {
  TGetInfoType::CLI_MAX_DRIVER_CONNECTIONS,
  TGetInfoType::CLI_MAX_CONCURRENT_ACTIVITIES,
  TGetInfoType::CLI_DATA_SOURCE_NAME,
  TGetInfoType::CLI_FETCH_DIRECTION,
  TGetInfoType::CLI_SERVER_NAME,
  TGetInfoType::CLI_SEARCH_PATTERN_ESCAPE,
  TGetInfoType::CLI_DBMS_NAME,
  TGetInfoType::CLI_DBMS_VER,
  TGetInfoType::CLI_ACCESSIBLE_TABLES,
  TGetInfoType::CLI_ACCESSIBLE_PROCEDURES,
  TGetInfoType::CLI_CURSOR_COMMIT_BEHAVIOR,
  TGetInfoType::CLI_DATA_SOURCE_READ_ONLY,
  TGetInfoType::CLI_DEFAULT_TXN_ISOLATION,
  TGetInfoType::CLI_IDENTIFIER_CASE,
  TGetInfoType::CLI_IDENTIFIER_QUOTE_CHAR,
  TGetInfoType::CLI_MAX_COLUMN_NAME_LEN,
  TGetInfoType::CLI_MAX_CURSOR_NAME_LEN,
  TGetInfoType::CLI_MAX_SCHEMA_NAME_LEN,
  TGetInfoType::CLI_MAX_CATALOG_NAME_LEN,
  TGetInfoType::CLI_MAX_TABLE_NAME_LEN,
  TGetInfoType::CLI_SCROLL_CONCURRENCY,
  TGetInfoType::CLI_TXN_CAPABLE,
  TGetInfoType::CLI_USER_NAME,
  TGetInfoType::CLI_TXN_ISOLATION_OPTION,
  TGetInfoType::CLI_INTEGRITY,
  TGetInfoType::CLI_GETDATA_EXTENSIONS,
  TGetInfoType::CLI_NULL_COLLATION,
  TGetInfoType::CLI_ALTER_TABLE,
  TGetInfoType::CLI_ORDER_BY_COLUMNS_IN_SELECT,
  TGetInfoType::CLI_SPECIAL_CHARACTERS,
  TGetInfoType::CLI_MAX_COLUMNS_IN_GROUP_BY,
  TGetInfoType::CLI_MAX_COLUMNS_IN_INDEX,
  TGetInfoType::CLI_MAX_COLUMNS_IN_ORDER_BY,
  TGetInfoType::CLI_MAX_COLUMNS_IN_SELECT,
  TGetInfoType::CLI_MAX_COLUMNS_IN_TABLE,
  TGetInfoType::CLI_MAX_INDEX_SIZE,
  TGetInfoType::CLI_MAX_ROW_SIZE,
  TGetInfoType::CLI_MAX_STATEMENT_LEN,
  TGetInfoType::CLI_MAX_TABLES_IN_SELECT,
  TGetInfoType::CLI_MAX_USER_NAME_LEN,
  TGetInfoType::CLI_OJ_CAPABILITIES,
  TGetInfoType::CLI_XOPEN_CLI_YEAR,
  TGetInfoType::CLI_CURSOR_SENSITIVITY,
  TGetInfoType::CLI_DESCRIBE_PARAMETER,
  TGetInfoType::CLI_CATALOG_NAME,
  TGetInfoType::CLI_COLLATION_SEQ,
  TGetInfoType::CLI_MAX_IDENTIFIER_LEN
};
const char* _kTGetInfoTypeNames[] = {
  "CLI_MAX_DRIVER_CONNECTIONS",
  "CLI_MAX_CONCURRENT_ACTIVITIES",
  "CLI_DATA_SOURCE_NAME",
  "CLI_FETCH_DIRECTION",
  "CLI_SERVER_NAME",
  "CLI_SEARCH_PATTERN_ESCAPE",
  "CLI_DBMS_NAME",
  "CLI_DBMS_VER",
  "CLI_ACCESSIBLE_TABLES",
  "CLI_ACCESSIBLE_PROCEDURES",
  "CLI_CURSOR_COMMIT_BEHAVIOR",
  "CLI_DATA_SOURCE_READ_ONLY",
  "CLI_DEFAULT_TXN_ISOLATION",
  "CLI_IDENTIFIER_CASE",
  "CLI_IDENTIFIER_QUOTE_CHAR",
  "CLI_MAX_COLUMN_NAME_LEN",
  "CLI_MAX_CURSOR_NAME_LEN",
  "CLI_MAX_SCHEMA_NAME_LEN",
  "CLI_MAX_CATALOG_NAME_LEN",
  "CLI_MAX_TABLE_NAME_LEN",
  "CLI_SCROLL_CONCURRENCY",
  "CLI_TXN_CAPABLE",
  "CLI_USER_NAME",
  "CLI_TXN_ISOLATION_OPTION",
  "CLI_INTEGRITY",
  "CLI_GETDATA_EXTENSIONS",
  "CLI_NULL_COLLATION",
  "CLI_ALTER_TABLE",
  "CLI_ORDER_BY_COLUMNS_IN_SELECT",
  "CLI_SPECIAL_CHARACTERS",
  "CLI_MAX_COLUMNS_IN_GROUP_BY",
  "CLI_MAX_COLUMNS_IN_INDEX",
  "CLI_MAX_COLUMNS_IN_ORDER_BY",
  "CLI_MAX_COLUMNS_IN_SELECT",
  "CLI_MAX_COLUMNS_IN_TABLE",
  "CLI_MAX_INDEX_SIZE",
  "CLI_MAX_ROW_SIZE",
  "CLI_MAX_STATEMENT_LEN",
  "CLI_MAX_TABLES_IN_SELECT",
  "CLI_MAX_USER_NAME_LEN",
  "CLI_OJ_CAPABILITIES",
  "CLI_XOPEN_CLI_YEAR",
  "CLI_CURSOR_SENSITIVITY",
  "CLI_DESCRIBE_PARAMETER",
  "CLI_CATALOG_NAME",
  "CLI_COLLATION_SEQ",
  "CLI_MAX_IDENTIFIER_LEN"
};
const std::map<int, const char*> _TGetInfoType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(47, _kTGetInfoTypeValues, _kTGetInfoTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTFetchOrientationValues[] = {
  TFetchOrientation::FETCH_NEXT,
  TFetchOrientation::FETCH_PRIOR,
  TFetchOrientation::FETCH_RELATIVE,
  TFetchOrientation::FETCH_ABSOLUTE,
  TFetchOrientation::FETCH_FIRST,
  TFetchOrientation::FETCH_LAST
};
const char* _kTFetchOrientationNames[] = {
  "FETCH_NEXT",
  "FETCH_PRIOR",
  "FETCH_RELATIVE",
  "FETCH_ABSOLUTE",
  "FETCH_FIRST",
  "FETCH_LAST"
};
const std::map<int, const char*> _TFetchOrientation_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kTFetchOrientationValues, _kTFetchOrientationNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


TTypeQualifierValue::~TTypeQualifierValue() throw() {
}


void TTypeQualifierValue::__set_i32Value(const int32_t val) {
  this->i32Value = val;
__isset.i32Value = true;
}

void TTypeQualifierValue::__set_stringValue(const std::string& val) {
  this->stringValue = val;
__isset.stringValue = true;
}

const char* TTypeQualifierValue::ascii_fingerprint = "A7801670116150C65ACA43E6F679BA79";
const uint8_t TTypeQualifierValue::binary_fingerprint[16] = {0xA7,0x80,0x16,0x70,0x11,0x61,0x50,0xC6,0x5A,0xCA,0x43,0xE6,0xF6,0x79,0xBA,0x79};

uint32_t TTypeQualifierValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->i32Value);
          this->__isset.i32Value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->stringValue);
          this->__isset.stringValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TTypeQualifierValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TTypeQualifierValue");

  if (this->__isset.i32Value) {
    xfer += oprot->writeFieldBegin("i32Value", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->i32Value);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.stringValue) {
    xfer += oprot->writeFieldBegin("stringValue", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->stringValue);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TTypeQualifierValue &a, TTypeQualifierValue &b) {
  using ::std::swap;
  swap(a.i32Value, b.i32Value);
  swap(a.stringValue, b.stringValue);
  swap(a.__isset, b.__isset);
}

TTypeQualifierValue::TTypeQualifierValue(const TTypeQualifierValue& other0) {
  i32Value = other0.i32Value;
  stringValue = other0.stringValue;
  __isset = other0.__isset;
}
TTypeQualifierValue& TTypeQualifierValue::operator=(const TTypeQualifierValue& other1) {
  i32Value = other1.i32Value;
  stringValue = other1.stringValue;
  __isset = other1.__isset;
  return *this;
}

TTypeQualifiers::~TTypeQualifiers() throw() {
}


void TTypeQualifiers::__set_qualifiers(const std::map<std::string, TTypeQualifierValue> & val) {
  this->qualifiers = val;
}

const char* TTypeQualifiers::ascii_fingerprint = "6C72981CFA989214285648FA8C196C47";
const uint8_t TTypeQualifiers::binary_fingerprint[16] = {0x6C,0x72,0x98,0x1C,0xFA,0x98,0x92,0x14,0x28,0x56,0x48,0xFA,0x8C,0x19,0x6C,0x47};

uint32_t TTypeQualifiers::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_qualifiers = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->qualifiers.clear();
            uint32_t _size2;
            ::apache::thrift::protocol::TType _ktype3;
            ::apache::thrift::protocol::TType _vtype4;
            xfer += iprot->readMapBegin(_ktype3, _vtype4, _size2);
            uint32_t _i6;
            for (_i6 = 0; _i6 < _size2; ++_i6)
            {
              std::string _key7;
              xfer += iprot->readString(_key7);
              TTypeQualifierValue& _val8 = this->qualifiers[_key7];
              xfer += _val8.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          isset_qualifiers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_qualifiers)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTypeQualifiers::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TTypeQualifiers");

  xfer += oprot->writeFieldBegin("qualifiers", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->qualifiers.size()));
    std::map<std::string, TTypeQualifierValue> ::const_iterator _iter9;
    for (_iter9 = this->qualifiers.begin(); _iter9 != this->qualifiers.end(); ++_iter9)
    {
      xfer += oprot->writeString(_iter9->first);
      xfer += _iter9->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TTypeQualifiers &a, TTypeQualifiers &b) {
  using ::std::swap;
  swap(a.qualifiers, b.qualifiers);
}

TTypeQualifiers::TTypeQualifiers(const TTypeQualifiers& other10) {
  qualifiers = other10.qualifiers;
}
TTypeQualifiers& TTypeQualifiers::operator=(const TTypeQualifiers& other11) {
  qualifiers = other11.qualifiers;
  return *this;
}

TPrimitiveTypeEntry::~TPrimitiveTypeEntry() throw() {
}


void TPrimitiveTypeEntry::__set_type(const TTypeId::type val) {
  this->type = val;
}

void TPrimitiveTypeEntry::__set_typeQualifiers(const TTypeQualifiers& val) {
  this->typeQualifiers = val;
__isset.typeQualifiers = true;
}

const char* TPrimitiveTypeEntry::ascii_fingerprint = "755674F6A5C8EB47868686AE386FBC1C";
const uint8_t TPrimitiveTypeEntry::binary_fingerprint[16] = {0x75,0x56,0x74,0xF6,0xA5,0xC8,0xEB,0x47,0x86,0x86,0x86,0xAE,0x38,0x6F,0xBC,0x1C};

uint32_t TPrimitiveTypeEntry::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast12;
          xfer += iprot->readI32(ecast12);
          this->type = (TTypeId::type)ecast12;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->typeQualifiers.read(iprot);
          this->__isset.typeQualifiers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPrimitiveTypeEntry::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TPrimitiveTypeEntry");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.typeQualifiers) {
    xfer += oprot->writeFieldBegin("typeQualifiers", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->typeQualifiers.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TPrimitiveTypeEntry &a, TPrimitiveTypeEntry &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.typeQualifiers, b.typeQualifiers);
  swap(a.__isset, b.__isset);
}

TPrimitiveTypeEntry::TPrimitiveTypeEntry(const TPrimitiveTypeEntry& other13) {
  type = other13.type;
  typeQualifiers = other13.typeQualifiers;
  __isset = other13.__isset;
}
TPrimitiveTypeEntry& TPrimitiveTypeEntry::operator=(const TPrimitiveTypeEntry& other14) {
  type = other14.type;
  typeQualifiers = other14.typeQualifiers;
  __isset = other14.__isset;
  return *this;
}

TArrayTypeEntry::~TArrayTypeEntry() throw() {
}


void TArrayTypeEntry::__set_objectTypePtr(const TTypeEntryPtr val) {
  this->objectTypePtr = val;
}

const char* TArrayTypeEntry::ascii_fingerprint = "E86CACEB22240450EDCBEFC3A83970E4";
const uint8_t TArrayTypeEntry::binary_fingerprint[16] = {0xE8,0x6C,0xAC,0xEB,0x22,0x24,0x04,0x50,0xED,0xCB,0xEF,0xC3,0xA8,0x39,0x70,0xE4};

uint32_t TArrayTypeEntry::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_objectTypePtr = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->objectTypePtr);
          isset_objectTypePtr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_objectTypePtr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TArrayTypeEntry::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TArrayTypeEntry");

  xfer += oprot->writeFieldBegin("objectTypePtr", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->objectTypePtr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TArrayTypeEntry &a, TArrayTypeEntry &b) {
  using ::std::swap;
  swap(a.objectTypePtr, b.objectTypePtr);
}

TArrayTypeEntry::TArrayTypeEntry(const TArrayTypeEntry& other15) {
  objectTypePtr = other15.objectTypePtr;
}
TArrayTypeEntry& TArrayTypeEntry::operator=(const TArrayTypeEntry& other16) {
  objectTypePtr = other16.objectTypePtr;
  return *this;
}

TMapTypeEntry::~TMapTypeEntry() throw() {
}


void TMapTypeEntry::__set_keyTypePtr(const TTypeEntryPtr val) {
  this->keyTypePtr = val;
}

void TMapTypeEntry::__set_valueTypePtr(const TTypeEntryPtr val) {
  this->valueTypePtr = val;
}

const char* TMapTypeEntry::ascii_fingerprint = "989D1F1AE8D148D5E2119FFEC4BBBEE3";
const uint8_t TMapTypeEntry::binary_fingerprint[16] = {0x98,0x9D,0x1F,0x1A,0xE8,0xD1,0x48,0xD5,0xE2,0x11,0x9F,0xFE,0xC4,0xBB,0xBE,0xE3};

uint32_t TMapTypeEntry::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_keyTypePtr = false;
  bool isset_valueTypePtr = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->keyTypePtr);
          isset_keyTypePtr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->valueTypePtr);
          isset_valueTypePtr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_keyTypePtr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_valueTypePtr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TMapTypeEntry::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TMapTypeEntry");

  xfer += oprot->writeFieldBegin("keyTypePtr", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->keyTypePtr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("valueTypePtr", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->valueTypePtr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TMapTypeEntry &a, TMapTypeEntry &b) {
  using ::std::swap;
  swap(a.keyTypePtr, b.keyTypePtr);
  swap(a.valueTypePtr, b.valueTypePtr);
}

TMapTypeEntry::TMapTypeEntry(const TMapTypeEntry& other17) {
  keyTypePtr = other17.keyTypePtr;
  valueTypePtr = other17.valueTypePtr;
}
TMapTypeEntry& TMapTypeEntry::operator=(const TMapTypeEntry& other18) {
  keyTypePtr = other18.keyTypePtr;
  valueTypePtr = other18.valueTypePtr;
  return *this;
}

TStructTypeEntry::~TStructTypeEntry() throw() {
}


void TStructTypeEntry::__set_nameToTypePtr(const std::map<std::string, TTypeEntryPtr> & val) {
  this->nameToTypePtr = val;
}

const char* TStructTypeEntry::ascii_fingerprint = "91F548CA159B4AB4291F5741AC161402";
const uint8_t TStructTypeEntry::binary_fingerprint[16] = {0x91,0xF5,0x48,0xCA,0x15,0x9B,0x4A,0xB4,0x29,0x1F,0x57,0x41,0xAC,0x16,0x14,0x02};

uint32_t TStructTypeEntry::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_nameToTypePtr = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->nameToTypePtr.clear();
            uint32_t _size19;
            ::apache::thrift::protocol::TType _ktype20;
            ::apache::thrift::protocol::TType _vtype21;
            xfer += iprot->readMapBegin(_ktype20, _vtype21, _size19);
            uint32_t _i23;
            for (_i23 = 0; _i23 < _size19; ++_i23)
            {
              std::string _key24;
              xfer += iprot->readString(_key24);
              TTypeEntryPtr& _val25 = this->nameToTypePtr[_key24];
              xfer += iprot->readI32(_val25);
            }
            xfer += iprot->readMapEnd();
          }
          isset_nameToTypePtr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_nameToTypePtr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TStructTypeEntry::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TStructTypeEntry");

  xfer += oprot->writeFieldBegin("nameToTypePtr", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->nameToTypePtr.size()));
    std::map<std::string, TTypeEntryPtr> ::const_iterator _iter26;
    for (_iter26 = this->nameToTypePtr.begin(); _iter26 != this->nameToTypePtr.end(); ++_iter26)
    {
      xfer += oprot->writeString(_iter26->first);
      xfer += oprot->writeI32(_iter26->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TStructTypeEntry &a, TStructTypeEntry &b) {
  using ::std::swap;
  swap(a.nameToTypePtr, b.nameToTypePtr);
}

TStructTypeEntry::TStructTypeEntry(const TStructTypeEntry& other27) {
  nameToTypePtr = other27.nameToTypePtr;
}
TStructTypeEntry& TStructTypeEntry::operator=(const TStructTypeEntry& other28) {
  nameToTypePtr = other28.nameToTypePtr;
  return *this;
}

TUnionTypeEntry::~TUnionTypeEntry() throw() {
}


void TUnionTypeEntry::__set_nameToTypePtr(const std::map<std::string, TTypeEntryPtr> & val) {
  this->nameToTypePtr = val;
}

const char* TUnionTypeEntry::ascii_fingerprint = "91F548CA159B4AB4291F5741AC161402";
const uint8_t TUnionTypeEntry::binary_fingerprint[16] = {0x91,0xF5,0x48,0xCA,0x15,0x9B,0x4A,0xB4,0x29,0x1F,0x57,0x41,0xAC,0x16,0x14,0x02};

uint32_t TUnionTypeEntry::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_nameToTypePtr = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->nameToTypePtr.clear();
            uint32_t _size29;
            ::apache::thrift::protocol::TType _ktype30;
            ::apache::thrift::protocol::TType _vtype31;
            xfer += iprot->readMapBegin(_ktype30, _vtype31, _size29);
            uint32_t _i33;
            for (_i33 = 0; _i33 < _size29; ++_i33)
            {
              std::string _key34;
              xfer += iprot->readString(_key34);
              TTypeEntryPtr& _val35 = this->nameToTypePtr[_key34];
              xfer += iprot->readI32(_val35);
            }
            xfer += iprot->readMapEnd();
          }
          isset_nameToTypePtr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_nameToTypePtr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TUnionTypeEntry::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TUnionTypeEntry");

  xfer += oprot->writeFieldBegin("nameToTypePtr", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->nameToTypePtr.size()));
    std::map<std::string, TTypeEntryPtr> ::const_iterator _iter36;
    for (_iter36 = this->nameToTypePtr.begin(); _iter36 != this->nameToTypePtr.end(); ++_iter36)
    {
      xfer += oprot->writeString(_iter36->first);
      xfer += oprot->writeI32(_iter36->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TUnionTypeEntry &a, TUnionTypeEntry &b) {
  using ::std::swap;
  swap(a.nameToTypePtr, b.nameToTypePtr);
}

TUnionTypeEntry::TUnionTypeEntry(const TUnionTypeEntry& other37) {
  nameToTypePtr = other37.nameToTypePtr;
}
TUnionTypeEntry& TUnionTypeEntry::operator=(const TUnionTypeEntry& other38) {
  nameToTypePtr = other38.nameToTypePtr;
  return *this;
}

TUserDefinedTypeEntry::~TUserDefinedTypeEntry() throw() {
}


void TUserDefinedTypeEntry::__set_typeClassName(const std::string& val) {
  this->typeClassName = val;
}

const char* TUserDefinedTypeEntry::ascii_fingerprint = "EFB929595D312AC8F305D5A794CFEDA1";
const uint8_t TUserDefinedTypeEntry::binary_fingerprint[16] = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

uint32_t TUserDefinedTypeEntry::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_typeClassName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->typeClassName);
          isset_typeClassName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_typeClassName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TUserDefinedTypeEntry::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TUserDefinedTypeEntry");

  xfer += oprot->writeFieldBegin("typeClassName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->typeClassName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TUserDefinedTypeEntry &a, TUserDefinedTypeEntry &b) {
  using ::std::swap;
  swap(a.typeClassName, b.typeClassName);
}

TUserDefinedTypeEntry::TUserDefinedTypeEntry(const TUserDefinedTypeEntry& other39) {
  typeClassName = other39.typeClassName;
}
TUserDefinedTypeEntry& TUserDefinedTypeEntry::operator=(const TUserDefinedTypeEntry& other40) {
  typeClassName = other40.typeClassName;
  return *this;
}

TTypeEntry::~TTypeEntry() throw() {
}


void TTypeEntry::__set_primitiveEntry(const TPrimitiveTypeEntry& val) {
  this->primitiveEntry = val;
}

void TTypeEntry::__set_arrayEntry(const TArrayTypeEntry& val) {
  this->arrayEntry = val;
}

void TTypeEntry::__set_mapEntry(const TMapTypeEntry& val) {
  this->mapEntry = val;
}

void TTypeEntry::__set_structEntry(const TStructTypeEntry& val) {
  this->structEntry = val;
}

void TTypeEntry::__set_unionEntry(const TUnionTypeEntry& val) {
  this->unionEntry = val;
}

void TTypeEntry::__set_userDefinedTypeEntry(const TUserDefinedTypeEntry& val) {
  this->userDefinedTypeEntry = val;
}

const char* TTypeEntry::ascii_fingerprint = "2FE56D9097E325DAA7E933738C6D325F";
const uint8_t TTypeEntry::binary_fingerprint[16] = {0x2F,0xE5,0x6D,0x90,0x97,0xE3,0x25,0xDA,0xA7,0xE9,0x33,0x73,0x8C,0x6D,0x32,0x5F};

uint32_t TTypeEntry::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->primitiveEntry.read(iprot);
          this->__isset.primitiveEntry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->arrayEntry.read(iprot);
          this->__isset.arrayEntry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->mapEntry.read(iprot);
          this->__isset.mapEntry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->structEntry.read(iprot);
          this->__isset.structEntry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->unionEntry.read(iprot);
          this->__isset.unionEntry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userDefinedTypeEntry.read(iprot);
          this->__isset.userDefinedTypeEntry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TTypeEntry::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TTypeEntry");

  xfer += oprot->writeFieldBegin("primitiveEntry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->primitiveEntry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arrayEntry", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->arrayEntry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mapEntry", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->mapEntry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("structEntry", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->structEntry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("unionEntry", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->unionEntry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userDefinedTypeEntry", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->userDefinedTypeEntry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TTypeEntry &a, TTypeEntry &b) {
  using ::std::swap;
  swap(a.primitiveEntry, b.primitiveEntry);
  swap(a.arrayEntry, b.arrayEntry);
  swap(a.mapEntry, b.mapEntry);
  swap(a.structEntry, b.structEntry);
  swap(a.unionEntry, b.unionEntry);
  swap(a.userDefinedTypeEntry, b.userDefinedTypeEntry);
  swap(a.__isset, b.__isset);
}

TTypeEntry::TTypeEntry(const TTypeEntry& other41) {
  primitiveEntry = other41.primitiveEntry;
  arrayEntry = other41.arrayEntry;
  mapEntry = other41.mapEntry;
  structEntry = other41.structEntry;
  unionEntry = other41.unionEntry;
  userDefinedTypeEntry = other41.userDefinedTypeEntry;
  __isset = other41.__isset;
}
TTypeEntry& TTypeEntry::operator=(const TTypeEntry& other42) {
  primitiveEntry = other42.primitiveEntry;
  arrayEntry = other42.arrayEntry;
  mapEntry = other42.mapEntry;
  structEntry = other42.structEntry;
  unionEntry = other42.unionEntry;
  userDefinedTypeEntry = other42.userDefinedTypeEntry;
  __isset = other42.__isset;
  return *this;
}

TTypeDesc::~TTypeDesc() throw() {
}


void TTypeDesc::__set_types(const std::vector<TTypeEntry> & val) {
  this->types = val;
}

const char* TTypeDesc::ascii_fingerprint = "90B3C5A0B73419A84E85E0E48C452AA5";
const uint8_t TTypeDesc::binary_fingerprint[16] = {0x90,0xB3,0xC5,0xA0,0xB7,0x34,0x19,0xA8,0x4E,0x85,0xE0,0xE4,0x8C,0x45,0x2A,0xA5};

uint32_t TTypeDesc::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_types = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->types.clear();
            uint32_t _size43;
            ::apache::thrift::protocol::TType _etype46;
            xfer += iprot->readListBegin(_etype46, _size43);
            this->types.resize(_size43);
            uint32_t _i47;
            for (_i47 = 0; _i47 < _size43; ++_i47)
            {
              xfer += this->types[_i47].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_types = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_types)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTypeDesc::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TTypeDesc");

  xfer += oprot->writeFieldBegin("types", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->types.size()));
    std::vector<TTypeEntry> ::const_iterator _iter48;
    for (_iter48 = this->types.begin(); _iter48 != this->types.end(); ++_iter48)
    {
      xfer += (*_iter48).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TTypeDesc &a, TTypeDesc &b) {
  using ::std::swap;
  swap(a.types, b.types);
}

TTypeDesc::TTypeDesc(const TTypeDesc& other49) {
  types = other49.types;
}
TTypeDesc& TTypeDesc::operator=(const TTypeDesc& other50) {
  types = other50.types;
  return *this;
}

TColumnDesc::~TColumnDesc() throw() {
}


void TColumnDesc::__set_columnName(const std::string& val) {
  this->columnName = val;
}

void TColumnDesc::__set_typeDesc(const TTypeDesc& val) {
  this->typeDesc = val;
}

void TColumnDesc::__set_position(const int32_t val) {
  this->position = val;
}

void TColumnDesc::__set_comment(const std::string& val) {
  this->comment = val;
__isset.comment = true;
}

const char* TColumnDesc::ascii_fingerprint = "EABED9009D5FCABFCA65612069F2A849";
const uint8_t TColumnDesc::binary_fingerprint[16] = {0xEA,0xBE,0xD9,0x00,0x9D,0x5F,0xCA,0xBF,0xCA,0x65,0x61,0x20,0x69,0xF2,0xA8,0x49};

uint32_t TColumnDesc::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_columnName = false;
  bool isset_typeDesc = false;
  bool isset_position = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->columnName);
          isset_columnName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->typeDesc.read(iprot);
          isset_typeDesc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->position);
          isset_position = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_columnName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_typeDesc)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_position)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TColumnDesc::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TColumnDesc");

  xfer += oprot->writeFieldBegin("columnName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->columnName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("typeDesc", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->typeDesc.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("position", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->position);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.comment) {
    xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->comment);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TColumnDesc &a, TColumnDesc &b) {
  using ::std::swap;
  swap(a.columnName, b.columnName);
  swap(a.typeDesc, b.typeDesc);
  swap(a.position, b.position);
  swap(a.comment, b.comment);
  swap(a.__isset, b.__isset);
}

TColumnDesc::TColumnDesc(const TColumnDesc& other51) {
  columnName = other51.columnName;
  typeDesc = other51.typeDesc;
  position = other51.position;
  comment = other51.comment;
  __isset = other51.__isset;
}
TColumnDesc& TColumnDesc::operator=(const TColumnDesc& other52) {
  columnName = other52.columnName;
  typeDesc = other52.typeDesc;
  position = other52.position;
  comment = other52.comment;
  __isset = other52.__isset;
  return *this;
}

TTableSchema::~TTableSchema() throw() {
}


void TTableSchema::__set_columns(const std::vector<TColumnDesc> & val) {
  this->columns = val;
}

const char* TTableSchema::ascii_fingerprint = "7A1811E49313E5977107FC667B20E39D";
const uint8_t TTableSchema::binary_fingerprint[16] = {0x7A,0x18,0x11,0xE4,0x93,0x13,0xE5,0x97,0x71,0x07,0xFC,0x66,0x7B,0x20,0xE3,0x9D};

uint32_t TTableSchema::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_columns = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size53;
            ::apache::thrift::protocol::TType _etype56;
            xfer += iprot->readListBegin(_etype56, _size53);
            this->columns.resize(_size53);
            uint32_t _i57;
            for (_i57 = 0; _i57 < _size53; ++_i57)
            {
              xfer += this->columns[_i57].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTableSchema::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TTableSchema");

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector<TColumnDesc> ::const_iterator _iter58;
    for (_iter58 = this->columns.begin(); _iter58 != this->columns.end(); ++_iter58)
    {
      xfer += (*_iter58).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TTableSchema &a, TTableSchema &b) {
  using ::std::swap;
  swap(a.columns, b.columns);
}

TTableSchema::TTableSchema(const TTableSchema& other59) {
  columns = other59.columns;
}
TTableSchema& TTableSchema::operator=(const TTableSchema& other60) {
  columns = other60.columns;
  return *this;
}

TBoolValue::~TBoolValue() throw() {
}


void TBoolValue::__set_value(const bool val) {
  this->value = val;
__isset.value = true;
}

const char* TBoolValue::ascii_fingerprint = "BF054652DEF86253C2BEE7D947F167DD";
const uint8_t TBoolValue::binary_fingerprint[16] = {0xBF,0x05,0x46,0x52,0xDE,0xF8,0x62,0x53,0xC2,0xBE,0xE7,0xD9,0x47,0xF1,0x67,0xDD};

uint32_t TBoolValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TBoolValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TBoolValue");

  if (this->__isset.value) {
    xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_BOOL, 1);
    xfer += oprot->writeBool(this->value);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TBoolValue &a, TBoolValue &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

TBoolValue::TBoolValue(const TBoolValue& other61) {
  value = other61.value;
  __isset = other61.__isset;
}
TBoolValue& TBoolValue::operator=(const TBoolValue& other62) {
  value = other62.value;
  __isset = other62.__isset;
  return *this;
}

TByteValue::~TByteValue() throw() {
}


void TByteValue::__set_value(const int8_t val) {
  this->value = val;
__isset.value = true;
}

const char* TByteValue::ascii_fingerprint = "9C15298ACB5D04AEA9B52D5DDE6F9208";
const uint8_t TByteValue::binary_fingerprint[16] = {0x9C,0x15,0x29,0x8A,0xCB,0x5D,0x04,0xAE,0xA9,0xB5,0x2D,0x5D,0xDE,0x6F,0x92,0x08};

uint32_t TByteValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TByteValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TByteValue");

  if (this->__isset.value) {
    xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_BYTE, 1);
    xfer += oprot->writeByte(this->value);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TByteValue &a, TByteValue &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

TByteValue::TByteValue(const TByteValue& other63) {
  value = other63.value;
  __isset = other63.__isset;
}
TByteValue& TByteValue::operator=(const TByteValue& other64) {
  value = other64.value;
  __isset = other64.__isset;
  return *this;
}

TI16Value::~TI16Value() throw() {
}


void TI16Value::__set_value(const int16_t val) {
  this->value = val;
__isset.value = true;
}

const char* TI16Value::ascii_fingerprint = "5DAC9C51C7E1106BF936FC71860BE9D5";
const uint8_t TI16Value::binary_fingerprint[16] = {0x5D,0xAC,0x9C,0x51,0xC7,0xE1,0x10,0x6B,0xF9,0x36,0xFC,0x71,0x86,0x0B,0xE9,0xD5};

uint32_t TI16Value::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TI16Value::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TI16Value");

  if (this->__isset.value) {
    xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_I16, 1);
    xfer += oprot->writeI16(this->value);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TI16Value &a, TI16Value &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

TI16Value::TI16Value(const TI16Value& other65) {
  value = other65.value;
  __isset = other65.__isset;
}
TI16Value& TI16Value::operator=(const TI16Value& other66) {
  value = other66.value;
  __isset = other66.__isset;
  return *this;
}

TI32Value::~TI32Value() throw() {
}


void TI32Value::__set_value(const int32_t val) {
  this->value = val;
__isset.value = true;
}

const char* TI32Value::ascii_fingerprint = "E7A96B151330359E84C0A3AC91BCBACD";
const uint8_t TI32Value::binary_fingerprint[16] = {0xE7,0xA9,0x6B,0x15,0x13,0x30,0x35,0x9E,0x84,0xC0,0xA3,0xAC,0x91,0xBC,0xBA,0xCD};

uint32_t TI32Value::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TI32Value::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TI32Value");

  if (this->__isset.value) {
    xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->value);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TI32Value &a, TI32Value &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

TI32Value::TI32Value(const TI32Value& other67) {
  value = other67.value;
  __isset = other67.__isset;
}
TI32Value& TI32Value::operator=(const TI32Value& other68) {
  value = other68.value;
  __isset = other68.__isset;
  return *this;
}

TI64Value::~TI64Value() throw() {
}


void TI64Value::__set_value(const int64_t val) {
  this->value = val;
__isset.value = true;
}

const char* TI64Value::ascii_fingerprint = "148F3AAAC1D9859963D5E800D187BF26";
const uint8_t TI64Value::binary_fingerprint[16] = {0x14,0x8F,0x3A,0xAA,0xC1,0xD9,0x85,0x99,0x63,0xD5,0xE8,0x00,0xD1,0x87,0xBF,0x26};

uint32_t TI64Value::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TI64Value::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TI64Value");

  if (this->__isset.value) {
    xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->value);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TI64Value &a, TI64Value &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

TI64Value::TI64Value(const TI64Value& other69) {
  value = other69.value;
  __isset = other69.__isset;
}
TI64Value& TI64Value::operator=(const TI64Value& other70) {
  value = other70.value;
  __isset = other70.__isset;
  return *this;
}

TDoubleValue::~TDoubleValue() throw() {
}


void TDoubleValue::__set_value(const double val) {
  this->value = val;
__isset.value = true;
}

const char* TDoubleValue::ascii_fingerprint = "3586E570A474C4A8603B4FF74903B3A6";
const uint8_t TDoubleValue::binary_fingerprint[16] = {0x35,0x86,0xE5,0x70,0xA4,0x74,0xC4,0xA8,0x60,0x3B,0x4F,0xF7,0x49,0x03,0xB3,0xA6};

uint32_t TDoubleValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDoubleValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TDoubleValue");

  if (this->__isset.value) {
    xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_DOUBLE, 1);
    xfer += oprot->writeDouble(this->value);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TDoubleValue &a, TDoubleValue &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

TDoubleValue::TDoubleValue(const TDoubleValue& other71) {
  value = other71.value;
  __isset = other71.__isset;
}
TDoubleValue& TDoubleValue::operator=(const TDoubleValue& other72) {
  value = other72.value;
  __isset = other72.__isset;
  return *this;
}

TStringValue::~TStringValue() throw() {
}


void TStringValue::__set_value(const std::string& val) {
  this->value = val;
__isset.value = true;
}

const char* TStringValue::ascii_fingerprint = "66E694018C17E5B65A59AE8F55CCA3CD";
const uint8_t TStringValue::binary_fingerprint[16] = {0x66,0xE6,0x94,0x01,0x8C,0x17,0xE5,0xB6,0x5A,0x59,0xAE,0x8F,0x55,0xCC,0xA3,0xCD};

uint32_t TStringValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TStringValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TStringValue");

  if (this->__isset.value) {
    xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->value);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TStringValue &a, TStringValue &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

TStringValue::TStringValue(const TStringValue& other73) {
  value = other73.value;
  __isset = other73.__isset;
}
TStringValue& TStringValue::operator=(const TStringValue& other74) {
  value = other74.value;
  __isset = other74.__isset;
  return *this;
}

TColumn::~TColumn() throw() {
}


void TColumn::__set_boolColumn(const std::vector<TBoolValue> & val) {
  this->boolColumn = val;
}

void TColumn::__set_byteColumn(const std::vector<TByteValue> & val) {
  this->byteColumn = val;
}

void TColumn::__set_i16Column(const std::vector<TI16Value> & val) {
  this->i16Column = val;
}

void TColumn::__set_i32Column(const std::vector<TI32Value> & val) {
  this->i32Column = val;
}

void TColumn::__set_i64Column(const std::vector<TI64Value> & val) {
  this->i64Column = val;
}

void TColumn::__set_doubleColumn(const std::vector<TDoubleValue> & val) {
  this->doubleColumn = val;
}

void TColumn::__set_stringColumn(const std::vector<TStringValue> & val) {
  this->stringColumn = val;
}

const char* TColumn::ascii_fingerprint = "B39B4E4E565DB31DC891D62FDC3208DC";
const uint8_t TColumn::binary_fingerprint[16] = {0xB3,0x9B,0x4E,0x4E,0x56,0x5D,0xB3,0x1D,0xC8,0x91,0xD6,0x2F,0xDC,0x32,0x08,0xDC};

uint32_t TColumn::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->boolColumn.clear();
            uint32_t _size75;
            ::apache::thrift::protocol::TType _etype78;
            xfer += iprot->readListBegin(_etype78, _size75);
            this->boolColumn.resize(_size75);
            uint32_t _i79;
            for (_i79 = 0; _i79 < _size75; ++_i79)
            {
              xfer += this->boolColumn[_i79].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.boolColumn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->byteColumn.clear();
            uint32_t _size80;
            ::apache::thrift::protocol::TType _etype83;
            xfer += iprot->readListBegin(_etype83, _size80);
            this->byteColumn.resize(_size80);
            uint32_t _i84;
            for (_i84 = 0; _i84 < _size80; ++_i84)
            {
              xfer += this->byteColumn[_i84].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.byteColumn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->i16Column.clear();
            uint32_t _size85;
            ::apache::thrift::protocol::TType _etype88;
            xfer += iprot->readListBegin(_etype88, _size85);
            this->i16Column.resize(_size85);
            uint32_t _i89;
            for (_i89 = 0; _i89 < _size85; ++_i89)
            {
              xfer += this->i16Column[_i89].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.i16Column = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->i32Column.clear();
            uint32_t _size90;
            ::apache::thrift::protocol::TType _etype93;
            xfer += iprot->readListBegin(_etype93, _size90);
            this->i32Column.resize(_size90);
            uint32_t _i94;
            for (_i94 = 0; _i94 < _size90; ++_i94)
            {
              xfer += this->i32Column[_i94].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.i32Column = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->i64Column.clear();
            uint32_t _size95;
            ::apache::thrift::protocol::TType _etype98;
            xfer += iprot->readListBegin(_etype98, _size95);
            this->i64Column.resize(_size95);
            uint32_t _i99;
            for (_i99 = 0; _i99 < _size95; ++_i99)
            {
              xfer += this->i64Column[_i99].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.i64Column = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->doubleColumn.clear();
            uint32_t _size100;
            ::apache::thrift::protocol::TType _etype103;
            xfer += iprot->readListBegin(_etype103, _size100);
            this->doubleColumn.resize(_size100);
            uint32_t _i104;
            for (_i104 = 0; _i104 < _size100; ++_i104)
            {
              xfer += this->doubleColumn[_i104].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.doubleColumn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->stringColumn.clear();
            uint32_t _size105;
            ::apache::thrift::protocol::TType _etype108;
            xfer += iprot->readListBegin(_etype108, _size105);
            this->stringColumn.resize(_size105);
            uint32_t _i109;
            for (_i109 = 0; _i109 < _size105; ++_i109)
            {
              xfer += this->stringColumn[_i109].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.stringColumn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TColumn::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TColumn");

  xfer += oprot->writeFieldBegin("boolColumn", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->boolColumn.size()));
    std::vector<TBoolValue> ::const_iterator _iter110;
    for (_iter110 = this->boolColumn.begin(); _iter110 != this->boolColumn.end(); ++_iter110)
    {
      xfer += (*_iter110).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("byteColumn", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->byteColumn.size()));
    std::vector<TByteValue> ::const_iterator _iter111;
    for (_iter111 = this->byteColumn.begin(); _iter111 != this->byteColumn.end(); ++_iter111)
    {
      xfer += (*_iter111).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("i16Column", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->i16Column.size()));
    std::vector<TI16Value> ::const_iterator _iter112;
    for (_iter112 = this->i16Column.begin(); _iter112 != this->i16Column.end(); ++_iter112)
    {
      xfer += (*_iter112).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("i32Column", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->i32Column.size()));
    std::vector<TI32Value> ::const_iterator _iter113;
    for (_iter113 = this->i32Column.begin(); _iter113 != this->i32Column.end(); ++_iter113)
    {
      xfer += (*_iter113).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("i64Column", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->i64Column.size()));
    std::vector<TI64Value> ::const_iterator _iter114;
    for (_iter114 = this->i64Column.begin(); _iter114 != this->i64Column.end(); ++_iter114)
    {
      xfer += (*_iter114).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("doubleColumn", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->doubleColumn.size()));
    std::vector<TDoubleValue> ::const_iterator _iter115;
    for (_iter115 = this->doubleColumn.begin(); _iter115 != this->doubleColumn.end(); ++_iter115)
    {
      xfer += (*_iter115).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stringColumn", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->stringColumn.size()));
    std::vector<TStringValue> ::const_iterator _iter116;
    for (_iter116 = this->stringColumn.begin(); _iter116 != this->stringColumn.end(); ++_iter116)
    {
      xfer += (*_iter116).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TColumn &a, TColumn &b) {
  using ::std::swap;
  swap(a.boolColumn, b.boolColumn);
  swap(a.byteColumn, b.byteColumn);
  swap(a.i16Column, b.i16Column);
  swap(a.i32Column, b.i32Column);
  swap(a.i64Column, b.i64Column);
  swap(a.doubleColumn, b.doubleColumn);
  swap(a.stringColumn, b.stringColumn);
  swap(a.__isset, b.__isset);
}

TColumn::TColumn(const TColumn& other117) {
  boolColumn = other117.boolColumn;
  byteColumn = other117.byteColumn;
  i16Column = other117.i16Column;
  i32Column = other117.i32Column;
  i64Column = other117.i64Column;
  doubleColumn = other117.doubleColumn;
  stringColumn = other117.stringColumn;
  __isset = other117.__isset;
}
TColumn& TColumn::operator=(const TColumn& other118) {
  boolColumn = other118.boolColumn;
  byteColumn = other118.byteColumn;
  i16Column = other118.i16Column;
  i32Column = other118.i32Column;
  i64Column = other118.i64Column;
  doubleColumn = other118.doubleColumn;
  stringColumn = other118.stringColumn;
  __isset = other118.__isset;
  return *this;
}

TColumnValue::~TColumnValue() throw() {
}


void TColumnValue::__set_boolVal(const TBoolValue& val) {
  this->boolVal = val;
}

void TColumnValue::__set_byteVal(const TByteValue& val) {
  this->byteVal = val;
}

void TColumnValue::__set_i16Val(const TI16Value& val) {
  this->i16Val = val;
}

void TColumnValue::__set_i32Val(const TI32Value& val) {
  this->i32Val = val;
}

void TColumnValue::__set_i64Val(const TI64Value& val) {
  this->i64Val = val;
}

void TColumnValue::__set_doubleVal(const TDoubleValue& val) {
  this->doubleVal = val;
}

void TColumnValue::__set_stringVal(const TStringValue& val) {
  this->stringVal = val;
}

const char* TColumnValue::ascii_fingerprint = "C2DDD988447EA7999A8285AA38AAE9AD";
const uint8_t TColumnValue::binary_fingerprint[16] = {0xC2,0xDD,0xD9,0x88,0x44,0x7E,0xA7,0x99,0x9A,0x82,0x85,0xAA,0x38,0xAA,0xE9,0xAD};

uint32_t TColumnValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->boolVal.read(iprot);
          this->__isset.boolVal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->byteVal.read(iprot);
          this->__isset.byteVal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->i16Val.read(iprot);
          this->__isset.i16Val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->i32Val.read(iprot);
          this->__isset.i32Val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->i64Val.read(iprot);
          this->__isset.i64Val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->doubleVal.read(iprot);
          this->__isset.doubleVal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stringVal.read(iprot);
          this->__isset.stringVal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TColumnValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TColumnValue");

  xfer += oprot->writeFieldBegin("boolVal", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->boolVal.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("byteVal", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->byteVal.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("i16Val", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->i16Val.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("i32Val", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->i32Val.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("i64Val", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->i64Val.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("doubleVal", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->doubleVal.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stringVal", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->stringVal.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TColumnValue &a, TColumnValue &b) {
  using ::std::swap;
  swap(a.boolVal, b.boolVal);
  swap(a.byteVal, b.byteVal);
  swap(a.i16Val, b.i16Val);
  swap(a.i32Val, b.i32Val);
  swap(a.i64Val, b.i64Val);
  swap(a.doubleVal, b.doubleVal);
  swap(a.stringVal, b.stringVal);
  swap(a.__isset, b.__isset);
}

TColumnValue::TColumnValue(const TColumnValue& other119) {
  boolVal = other119.boolVal;
  byteVal = other119.byteVal;
  i16Val = other119.i16Val;
  i32Val = other119.i32Val;
  i64Val = other119.i64Val;
  doubleVal = other119.doubleVal;
  stringVal = other119.stringVal;
  __isset = other119.__isset;
}
TColumnValue& TColumnValue::operator=(const TColumnValue& other120) {
  boolVal = other120.boolVal;
  byteVal = other120.byteVal;
  i16Val = other120.i16Val;
  i32Val = other120.i32Val;
  i64Val = other120.i64Val;
  doubleVal = other120.doubleVal;
  stringVal = other120.stringVal;
  __isset = other120.__isset;
  return *this;
}

TRow::~TRow() throw() {
}


void TRow::__set_colVals(const std::vector<TColumnValue> & val) {
  this->colVals = val;
}

const char* TRow::ascii_fingerprint = "E73FD1FCA0CA58A669FC3E02FB68D534";
const uint8_t TRow::binary_fingerprint[16] = {0xE7,0x3F,0xD1,0xFC,0xA0,0xCA,0x58,0xA6,0x69,0xFC,0x3E,0x02,0xFB,0x68,0xD5,0x34};

uint32_t TRow::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_colVals = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->colVals.clear();
            uint32_t _size121;
            ::apache::thrift::protocol::TType _etype124;
            xfer += iprot->readListBegin(_etype124, _size121);
            this->colVals.resize(_size121);
            uint32_t _i125;
            for (_i125 = 0; _i125 < _size121; ++_i125)
            {
              xfer += this->colVals[_i125].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_colVals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_colVals)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TRow::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TRow");

  xfer += oprot->writeFieldBegin("colVals", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->colVals.size()));
    std::vector<TColumnValue> ::const_iterator _iter126;
    for (_iter126 = this->colVals.begin(); _iter126 != this->colVals.end(); ++_iter126)
    {
      xfer += (*_iter126).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TRow &a, TRow &b) {
  using ::std::swap;
  swap(a.colVals, b.colVals);
}

TRow::TRow(const TRow& other127) {
  colVals = other127.colVals;
}
TRow& TRow::operator=(const TRow& other128) {
  colVals = other128.colVals;
  return *this;
}

TRowSet::~TRowSet() throw() {
}


void TRowSet::__set_startRowOffset(const int64_t val) {
  this->startRowOffset = val;
}

void TRowSet::__set_rows(const std::vector<TRow> & val) {
  this->rows = val;
}

void TRowSet::__set_columns(const std::vector<TColumn> & val) {
  this->columns = val;
__isset.columns = true;
}

const char* TRowSet::ascii_fingerprint = "698727A24268879440EE0DAFE68FC1C5";
const uint8_t TRowSet::binary_fingerprint[16] = {0x69,0x87,0x27,0xA2,0x42,0x68,0x87,0x94,0x40,0xEE,0x0D,0xAF,0xE6,0x8F,0xC1,0xC5};

uint32_t TRowSet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_startRowOffset = false;
  bool isset_rows = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->startRowOffset);
          isset_startRowOffset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->rows.clear();
            uint32_t _size129;
            ::apache::thrift::protocol::TType _etype132;
            xfer += iprot->readListBegin(_etype132, _size129);
            this->rows.resize(_size129);
            uint32_t _i133;
            for (_i133 = 0; _i133 < _size129; ++_i133)
            {
              xfer += this->rows[_i133].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size134;
            ::apache::thrift::protocol::TType _etype137;
            xfer += iprot->readListBegin(_etype137, _size134);
            this->columns.resize(_size134);
            uint32_t _i138;
            for (_i138 = 0; _i138 < _size134; ++_i138)
            {
              xfer += this->columns[_i138].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_startRowOffset)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_rows)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TRowSet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TRowSet");

  xfer += oprot->writeFieldBegin("startRowOffset", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->startRowOffset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rows", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->rows.size()));
    std::vector<TRow> ::const_iterator _iter139;
    for (_iter139 = this->rows.begin(); _iter139 != this->rows.end(); ++_iter139)
    {
      xfer += (*_iter139).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.columns) {
    xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
      std::vector<TColumn> ::const_iterator _iter140;
      for (_iter140 = this->columns.begin(); _iter140 != this->columns.end(); ++_iter140)
      {
        xfer += (*_iter140).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TRowSet &a, TRowSet &b) {
  using ::std::swap;
  swap(a.startRowOffset, b.startRowOffset);
  swap(a.rows, b.rows);
  swap(a.columns, b.columns);
  swap(a.__isset, b.__isset);
}

TRowSet::TRowSet(const TRowSet& other141) {
  startRowOffset = other141.startRowOffset;
  rows = other141.rows;
  columns = other141.columns;
  __isset = other141.__isset;
}
TRowSet& TRowSet::operator=(const TRowSet& other142) {
  startRowOffset = other142.startRowOffset;
  rows = other142.rows;
  columns = other142.columns;
  __isset = other142.__isset;
  return *this;
}

TStatus::~TStatus() throw() {
}


void TStatus::__set_statusCode(const TStatusCode::type val) {
  this->statusCode = val;
}

void TStatus::__set_infoMessages(const std::vector<std::string> & val) {
  this->infoMessages = val;
__isset.infoMessages = true;
}

void TStatus::__set_sqlState(const std::string& val) {
  this->sqlState = val;
__isset.sqlState = true;
}

void TStatus::__set_errorCode(const int32_t val) {
  this->errorCode = val;
__isset.errorCode = true;
}

void TStatus::__set_errorMessage(const std::string& val) {
  this->errorMessage = val;
__isset.errorMessage = true;
}

const char* TStatus::ascii_fingerprint = "D5DEF49634A59C615C1B3A6F7D0DADB5";
const uint8_t TStatus::binary_fingerprint[16] = {0xD5,0xDE,0xF4,0x96,0x34,0xA5,0x9C,0x61,0x5C,0x1B,0x3A,0x6F,0x7D,0x0D,0xAD,0xB5};

uint32_t TStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_statusCode = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast143;
          xfer += iprot->readI32(ecast143);
          this->statusCode = (TStatusCode::type)ecast143;
          isset_statusCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->infoMessages.clear();
            uint32_t _size144;
            ::apache::thrift::protocol::TType _etype147;
            xfer += iprot->readListBegin(_etype147, _size144);
            this->infoMessages.resize(_size144);
            uint32_t _i148;
            for (_i148 = 0; _i148 < _size144; ++_i148)
            {
              xfer += iprot->readString(this->infoMessages[_i148]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.infoMessages = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sqlState);
          this->__isset.sqlState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->errorCode);
          this->__isset.errorCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->errorMessage);
          this->__isset.errorMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_statusCode)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TStatus");

  xfer += oprot->writeFieldBegin("statusCode", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->statusCode);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.infoMessages) {
    xfer += oprot->writeFieldBegin("infoMessages", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->infoMessages.size()));
      std::vector<std::string> ::const_iterator _iter149;
      for (_iter149 = this->infoMessages.begin(); _iter149 != this->infoMessages.end(); ++_iter149)
      {
        xfer += oprot->writeString((*_iter149));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sqlState) {
    xfer += oprot->writeFieldBegin("sqlState", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->sqlState);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.errorCode) {
    xfer += oprot->writeFieldBegin("errorCode", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->errorCode);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.errorMessage) {
    xfer += oprot->writeFieldBegin("errorMessage", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->errorMessage);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TStatus &a, TStatus &b) {
  using ::std::swap;
  swap(a.statusCode, b.statusCode);
  swap(a.infoMessages, b.infoMessages);
  swap(a.sqlState, b.sqlState);
  swap(a.errorCode, b.errorCode);
  swap(a.errorMessage, b.errorMessage);
  swap(a.__isset, b.__isset);
}

TStatus::TStatus(const TStatus& other150) {
  statusCode = other150.statusCode;
  infoMessages = other150.infoMessages;
  sqlState = other150.sqlState;
  errorCode = other150.errorCode;
  errorMessage = other150.errorMessage;
  __isset = other150.__isset;
}
TStatus& TStatus::operator=(const TStatus& other151) {
  statusCode = other151.statusCode;
  infoMessages = other151.infoMessages;
  sqlState = other151.sqlState;
  errorCode = other151.errorCode;
  errorMessage = other151.errorMessage;
  __isset = other151.__isset;
  return *this;
}

THandleIdentifier::~THandleIdentifier() throw() {
}


void THandleIdentifier::__set_guid(const std::string& val) {
  this->guid = val;
}

void THandleIdentifier::__set_secret(const std::string& val) {
  this->secret = val;
}

const char* THandleIdentifier::ascii_fingerprint = "07A9615F837F7D0A952B595DD3020972";
const uint8_t THandleIdentifier::binary_fingerprint[16] = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

uint32_t THandleIdentifier::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_guid = false;
  bool isset_secret = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->guid);
          isset_guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->secret);
          isset_secret = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_guid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_secret)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t THandleIdentifier::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("THandleIdentifier");

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->guid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("secret", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->secret);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(THandleIdentifier &a, THandleIdentifier &b) {
  using ::std::swap;
  swap(a.guid, b.guid);
  swap(a.secret, b.secret);
}

THandleIdentifier::THandleIdentifier(const THandleIdentifier& other152) {
  guid = other152.guid;
  secret = other152.secret;
}
THandleIdentifier& THandleIdentifier::operator=(const THandleIdentifier& other153) {
  guid = other153.guid;
  secret = other153.secret;
  return *this;
}

TSessionHandle::~TSessionHandle() throw() {
}


void TSessionHandle::__set_sessionId(const THandleIdentifier& val) {
  this->sessionId = val;
}

const char* TSessionHandle::ascii_fingerprint = "A756D3DBE614FB13F70BF7F7B6EB3D73";
const uint8_t TSessionHandle::binary_fingerprint[16] = {0xA7,0x56,0xD3,0xDB,0xE6,0x14,0xFB,0x13,0xF7,0x0B,0xF7,0xF7,0xB6,0xEB,0x3D,0x73};

uint32_t TSessionHandle::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionId.read(iprot);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSessionHandle::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TSessionHandle");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionId.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TSessionHandle &a, TSessionHandle &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
}

TSessionHandle::TSessionHandle(const TSessionHandle& other154) {
  sessionId = other154.sessionId;
}
TSessionHandle& TSessionHandle::operator=(const TSessionHandle& other155) {
  sessionId = other155.sessionId;
  return *this;
}

TOperationHandle::~TOperationHandle() throw() {
}


void TOperationHandle::__set_operationId(const THandleIdentifier& val) {
  this->operationId = val;
}

void TOperationHandle::__set_operationType(const TOperationType::type val) {
  this->operationType = val;
}

void TOperationHandle::__set_hasResultSet(const bool val) {
  this->hasResultSet = val;
}

void TOperationHandle::__set_modifiedRowCount(const double val) {
  this->modifiedRowCount = val;
__isset.modifiedRowCount = true;
}

const char* TOperationHandle::ascii_fingerprint = "29FD80F4F96804A30FCC59C23D2E5349";
const uint8_t TOperationHandle::binary_fingerprint[16] = {0x29,0xFD,0x80,0xF4,0xF9,0x68,0x04,0xA3,0x0F,0xCC,0x59,0xC2,0x3D,0x2E,0x53,0x49};

uint32_t TOperationHandle::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_operationId = false;
  bool isset_operationType = false;
  bool isset_hasResultSet = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationId.read(iprot);
          isset_operationId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast156;
          xfer += iprot->readI32(ecast156);
          this->operationType = (TOperationType::type)ecast156;
          isset_operationType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->hasResultSet);
          isset_hasResultSet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->modifiedRowCount);
          this->__isset.modifiedRowCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_operationId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_operationType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_hasResultSet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TOperationHandle::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TOperationHandle");

  xfer += oprot->writeFieldBegin("operationId", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->operationId.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("operationType", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->operationType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hasResultSet", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->hasResultSet);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.modifiedRowCount) {
    xfer += oprot->writeFieldBegin("modifiedRowCount", ::apache::thrift::protocol::T_DOUBLE, 4);
    xfer += oprot->writeDouble(this->modifiedRowCount);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TOperationHandle &a, TOperationHandle &b) {
  using ::std::swap;
  swap(a.operationId, b.operationId);
  swap(a.operationType, b.operationType);
  swap(a.hasResultSet, b.hasResultSet);
  swap(a.modifiedRowCount, b.modifiedRowCount);
  swap(a.__isset, b.__isset);
}

TOperationHandle::TOperationHandle(const TOperationHandle& other157) {
  operationId = other157.operationId;
  operationType = other157.operationType;
  hasResultSet = other157.hasResultSet;
  modifiedRowCount = other157.modifiedRowCount;
  __isset = other157.__isset;
}
TOperationHandle& TOperationHandle::operator=(const TOperationHandle& other158) {
  operationId = other158.operationId;
  operationType = other158.operationType;
  hasResultSet = other158.hasResultSet;
  modifiedRowCount = other158.modifiedRowCount;
  __isset = other158.__isset;
  return *this;
}

TOpenSessionReq::~TOpenSessionReq() throw() {
}


void TOpenSessionReq::__set_client_protocol(const TProtocolVersion::type val) {
  this->client_protocol = val;
}

void TOpenSessionReq::__set_username(const std::string& val) {
  this->username = val;
__isset.username = true;
}

void TOpenSessionReq::__set_password(const std::string& val) {
  this->password = val;
__isset.password = true;
}

void TOpenSessionReq::__set_configuration(const std::map<std::string, std::string> & val) {
  this->configuration = val;
__isset.configuration = true;
}

const char* TOpenSessionReq::ascii_fingerprint = "C8FD0F306A16C16BDA7B57F58BFAE5B2";
const uint8_t TOpenSessionReq::binary_fingerprint[16] = {0xC8,0xFD,0x0F,0x30,0x6A,0x16,0xC1,0x6B,0xDA,0x7B,0x57,0xF5,0x8B,0xFA,0xE5,0xB2};

uint32_t TOpenSessionReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_client_protocol = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast159;
          xfer += iprot->readI32(ecast159);
          this->client_protocol = (TProtocolVersion::type)ecast159;
          isset_client_protocol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->username);
          this->__isset.username = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          this->__isset.password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->configuration.clear();
            uint32_t _size160;
            ::apache::thrift::protocol::TType _ktype161;
            ::apache::thrift::protocol::TType _vtype162;
            xfer += iprot->readMapBegin(_ktype161, _vtype162, _size160);
            uint32_t _i164;
            for (_i164 = 0; _i164 < _size160; ++_i164)
            {
              std::string _key165;
              xfer += iprot->readString(_key165);
              std::string& _val166 = this->configuration[_key165];
              xfer += iprot->readString(_val166);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.configuration = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_client_protocol)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TOpenSessionReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TOpenSessionReq");

  xfer += oprot->writeFieldBegin("client_protocol", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->client_protocol);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.username) {
    xfer += oprot->writeFieldBegin("username", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->username);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.password) {
    xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->password);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.configuration) {
    xfer += oprot->writeFieldBegin("configuration", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->configuration.size()));
      std::map<std::string, std::string> ::const_iterator _iter167;
      for (_iter167 = this->configuration.begin(); _iter167 != this->configuration.end(); ++_iter167)
      {
        xfer += oprot->writeString(_iter167->first);
        xfer += oprot->writeString(_iter167->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TOpenSessionReq &a, TOpenSessionReq &b) {
  using ::std::swap;
  swap(a.client_protocol, b.client_protocol);
  swap(a.username, b.username);
  swap(a.password, b.password);
  swap(a.configuration, b.configuration);
  swap(a.__isset, b.__isset);
}

TOpenSessionReq::TOpenSessionReq(const TOpenSessionReq& other168) {
  client_protocol = other168.client_protocol;
  username = other168.username;
  password = other168.password;
  configuration = other168.configuration;
  __isset = other168.__isset;
}
TOpenSessionReq& TOpenSessionReq::operator=(const TOpenSessionReq& other169) {
  client_protocol = other169.client_protocol;
  username = other169.username;
  password = other169.password;
  configuration = other169.configuration;
  __isset = other169.__isset;
  return *this;
}

TOpenSessionResp::~TOpenSessionResp() throw() {
}


void TOpenSessionResp::__set_status(const TStatus& val) {
  this->status = val;
}

void TOpenSessionResp::__set_serverProtocolVersion(const TProtocolVersion::type val) {
  this->serverProtocolVersion = val;
}

void TOpenSessionResp::__set_sessionHandle(const TSessionHandle& val) {
  this->sessionHandle = val;
__isset.sessionHandle = true;
}

void TOpenSessionResp::__set_configuration(const std::map<std::string, std::string> & val) {
  this->configuration = val;
__isset.configuration = true;
}

const char* TOpenSessionResp::ascii_fingerprint = "CFE7D7F4E9EC671F2518ED74FEE9F163";
const uint8_t TOpenSessionResp::binary_fingerprint[16] = {0xCF,0xE7,0xD7,0xF4,0xE9,0xEC,0x67,0x1F,0x25,0x18,0xED,0x74,0xFE,0xE9,0xF1,0x63};

uint32_t TOpenSessionResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;
  bool isset_serverProtocolVersion = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast170;
          xfer += iprot->readI32(ecast170);
          this->serverProtocolVersion = (TProtocolVersion::type)ecast170;
          isset_serverProtocolVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          this->__isset.sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->configuration.clear();
            uint32_t _size171;
            ::apache::thrift::protocol::TType _ktype172;
            ::apache::thrift::protocol::TType _vtype173;
            xfer += iprot->readMapBegin(_ktype172, _vtype173, _size171);
            uint32_t _i175;
            for (_i175 = 0; _i175 < _size171; ++_i175)
            {
              std::string _key176;
              xfer += iprot->readString(_key176);
              std::string& _val177 = this->configuration[_key176];
              xfer += iprot->readString(_val177);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.configuration = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_serverProtocolVersion)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TOpenSessionResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TOpenSessionResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serverProtocolVersion", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->serverProtocolVersion);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.sessionHandle) {
    xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->sessionHandle.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.configuration) {
    xfer += oprot->writeFieldBegin("configuration", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->configuration.size()));
      std::map<std::string, std::string> ::const_iterator _iter178;
      for (_iter178 = this->configuration.begin(); _iter178 != this->configuration.end(); ++_iter178)
      {
        xfer += oprot->writeString(_iter178->first);
        xfer += oprot->writeString(_iter178->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TOpenSessionResp &a, TOpenSessionResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.serverProtocolVersion, b.serverProtocolVersion);
  swap(a.sessionHandle, b.sessionHandle);
  swap(a.configuration, b.configuration);
  swap(a.__isset, b.__isset);
}

TOpenSessionResp::TOpenSessionResp(const TOpenSessionResp& other179) {
  status = other179.status;
  serverProtocolVersion = other179.serverProtocolVersion;
  sessionHandle = other179.sessionHandle;
  configuration = other179.configuration;
  __isset = other179.__isset;
}
TOpenSessionResp& TOpenSessionResp::operator=(const TOpenSessionResp& other180) {
  status = other180.status;
  serverProtocolVersion = other180.serverProtocolVersion;
  sessionHandle = other180.sessionHandle;
  configuration = other180.configuration;
  __isset = other180.__isset;
  return *this;
}

TCloseSessionReq::~TCloseSessionReq() throw() {
}


void TCloseSessionReq::__set_sessionHandle(const TSessionHandle& val) {
  this->sessionHandle = val;
}

const char* TCloseSessionReq::ascii_fingerprint = "82377107F8BD0526960537D5A112E6EF";
const uint8_t TCloseSessionReq::binary_fingerprint[16] = {0x82,0x37,0x71,0x07,0xF8,0xBD,0x05,0x26,0x96,0x05,0x37,0xD5,0xA1,0x12,0xE6,0xEF};

uint32_t TCloseSessionReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionHandle = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          isset_sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCloseSessionReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TCloseSessionReq");

  xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TCloseSessionReq &a, TCloseSessionReq &b) {
  using ::std::swap;
  swap(a.sessionHandle, b.sessionHandle);
}

TCloseSessionReq::TCloseSessionReq(const TCloseSessionReq& other181) {
  sessionHandle = other181.sessionHandle;
}
TCloseSessionReq& TCloseSessionReq::operator=(const TCloseSessionReq& other182) {
  sessionHandle = other182.sessionHandle;
  return *this;
}

TCloseSessionResp::~TCloseSessionResp() throw() {
}


void TCloseSessionResp::__set_status(const TStatus& val) {
  this->status = val;
}

const char* TCloseSessionResp::ascii_fingerprint = "7142E89F09DC7C5F6FA916C7393F46C2";
const uint8_t TCloseSessionResp::binary_fingerprint[16] = {0x71,0x42,0xE8,0x9F,0x09,0xDC,0x7C,0x5F,0x6F,0xA9,0x16,0xC7,0x39,0x3F,0x46,0xC2};

uint32_t TCloseSessionResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCloseSessionResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TCloseSessionResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TCloseSessionResp &a, TCloseSessionResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
}

TCloseSessionResp::TCloseSessionResp(const TCloseSessionResp& other183) {
  status = other183.status;
}
TCloseSessionResp& TCloseSessionResp::operator=(const TCloseSessionResp& other184) {
  status = other184.status;
  return *this;
}

TGetInfoValue::~TGetInfoValue() throw() {
}


void TGetInfoValue::__set_stringValue(const std::string& val) {
  this->stringValue = val;
}

void TGetInfoValue::__set_smallIntValue(const int16_t val) {
  this->smallIntValue = val;
}

void TGetInfoValue::__set_integerBitmask(const int32_t val) {
  this->integerBitmask = val;
}

void TGetInfoValue::__set_integerFlag(const int32_t val) {
  this->integerFlag = val;
}

void TGetInfoValue::__set_binaryValue(const int32_t val) {
  this->binaryValue = val;
}

void TGetInfoValue::__set_lenValue(const int64_t val) {
  this->lenValue = val;
}

const char* TGetInfoValue::ascii_fingerprint = "057FED11279FD7248CFE73EE82ED579E";
const uint8_t TGetInfoValue::binary_fingerprint[16] = {0x05,0x7F,0xED,0x11,0x27,0x9F,0xD7,0x24,0x8C,0xFE,0x73,0xEE,0x82,0xED,0x57,0x9E};

uint32_t TGetInfoValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->stringValue);
          this->__isset.stringValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->smallIntValue);
          this->__isset.smallIntValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->integerBitmask);
          this->__isset.integerBitmask = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->integerFlag);
          this->__isset.integerFlag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->binaryValue);
          this->__isset.binaryValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lenValue);
          this->__isset.lenValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TGetInfoValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TGetInfoValue");

  xfer += oprot->writeFieldBegin("stringValue", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->stringValue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("smallIntValue", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->smallIntValue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("integerBitmask", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->integerBitmask);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("integerFlag", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->integerFlag);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("binaryValue", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->binaryValue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lenValue", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->lenValue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TGetInfoValue &a, TGetInfoValue &b) {
  using ::std::swap;
  swap(a.stringValue, b.stringValue);
  swap(a.smallIntValue, b.smallIntValue);
  swap(a.integerBitmask, b.integerBitmask);
  swap(a.integerFlag, b.integerFlag);
  swap(a.binaryValue, b.binaryValue);
  swap(a.lenValue, b.lenValue);
  swap(a.__isset, b.__isset);
}

TGetInfoValue::TGetInfoValue(const TGetInfoValue& other185) {
  stringValue = other185.stringValue;
  smallIntValue = other185.smallIntValue;
  integerBitmask = other185.integerBitmask;
  integerFlag = other185.integerFlag;
  binaryValue = other185.binaryValue;
  lenValue = other185.lenValue;
  __isset = other185.__isset;
}
TGetInfoValue& TGetInfoValue::operator=(const TGetInfoValue& other186) {
  stringValue = other186.stringValue;
  smallIntValue = other186.smallIntValue;
  integerBitmask = other186.integerBitmask;
  integerFlag = other186.integerFlag;
  binaryValue = other186.binaryValue;
  lenValue = other186.lenValue;
  __isset = other186.__isset;
  return *this;
}

TGetInfoReq::~TGetInfoReq() throw() {
}


void TGetInfoReq::__set_sessionHandle(const TSessionHandle& val) {
  this->sessionHandle = val;
}

void TGetInfoReq::__set_infoType(const TGetInfoType::type val) {
  this->infoType = val;
}

const char* TGetInfoReq::ascii_fingerprint = "95675B1A0BADE5F7EDE323809DB679B2";
const uint8_t TGetInfoReq::binary_fingerprint[16] = {0x95,0x67,0x5B,0x1A,0x0B,0xAD,0xE5,0xF7,0xED,0xE3,0x23,0x80,0x9D,0xB6,0x79,0xB2};

uint32_t TGetInfoReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionHandle = false;
  bool isset_infoType = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          isset_sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast187;
          xfer += iprot->readI32(ecast187);
          this->infoType = (TGetInfoType::type)ecast187;
          isset_infoType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_infoType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetInfoReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TGetInfoReq");

  xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("infoType", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->infoType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TGetInfoReq &a, TGetInfoReq &b) {
  using ::std::swap;
  swap(a.sessionHandle, b.sessionHandle);
  swap(a.infoType, b.infoType);
}

TGetInfoReq::TGetInfoReq(const TGetInfoReq& other188) {
  sessionHandle = other188.sessionHandle;
  infoType = other188.infoType;
}
TGetInfoReq& TGetInfoReq::operator=(const TGetInfoReq& other189) {
  sessionHandle = other189.sessionHandle;
  infoType = other189.infoType;
  return *this;
}

TGetInfoResp::~TGetInfoResp() throw() {
}


void TGetInfoResp::__set_status(const TStatus& val) {
  this->status = val;
}

void TGetInfoResp::__set_infoValue(const TGetInfoValue& val) {
  this->infoValue = val;
}

const char* TGetInfoResp::ascii_fingerprint = "72AFA10A82728B51FDE91092012868DE";
const uint8_t TGetInfoResp::binary_fingerprint[16] = {0x72,0xAF,0xA1,0x0A,0x82,0x72,0x8B,0x51,0xFD,0xE9,0x10,0x92,0x01,0x28,0x68,0xDE};

uint32_t TGetInfoResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;
  bool isset_infoValue = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->infoValue.read(iprot);
          isset_infoValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_infoValue)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetInfoResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TGetInfoResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("infoValue", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->infoValue.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TGetInfoResp &a, TGetInfoResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.infoValue, b.infoValue);
}

TGetInfoResp::TGetInfoResp(const TGetInfoResp& other190) {
  status = other190.status;
  infoValue = other190.infoValue;
}
TGetInfoResp& TGetInfoResp::operator=(const TGetInfoResp& other191) {
  status = other191.status;
  infoValue = other191.infoValue;
  return *this;
}

TExecuteStatementReq::~TExecuteStatementReq() throw() {
}


void TExecuteStatementReq::__set_sessionHandle(const TSessionHandle& val) {
  this->sessionHandle = val;
}

void TExecuteStatementReq::__set_statement(const std::string& val) {
  this->statement = val;
}

void TExecuteStatementReq::__set_confOverlay(const std::map<std::string, std::string> & val) {
  this->confOverlay = val;
__isset.confOverlay = true;
}

void TExecuteStatementReq::__set_runAsync(const bool val) {
  this->runAsync = val;
__isset.runAsync = true;
}

const char* TExecuteStatementReq::ascii_fingerprint = "FED75DB77E66D76EC1939A51FB0D96FA";
const uint8_t TExecuteStatementReq::binary_fingerprint[16] = {0xFE,0xD7,0x5D,0xB7,0x7E,0x66,0xD7,0x6E,0xC1,0x93,0x9A,0x51,0xFB,0x0D,0x96,0xFA};

uint32_t TExecuteStatementReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionHandle = false;
  bool isset_statement = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          isset_sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->statement);
          isset_statement = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->confOverlay.clear();
            uint32_t _size192;
            ::apache::thrift::protocol::TType _ktype193;
            ::apache::thrift::protocol::TType _vtype194;
            xfer += iprot->readMapBegin(_ktype193, _vtype194, _size192);
            uint32_t _i196;
            for (_i196 = 0; _i196 < _size192; ++_i196)
            {
              std::string _key197;
              xfer += iprot->readString(_key197);
              std::string& _val198 = this->confOverlay[_key197];
              xfer += iprot->readString(_val198);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.confOverlay = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->runAsync);
          this->__isset.runAsync = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_statement)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TExecuteStatementReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TExecuteStatementReq");

  xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("statement", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->statement);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.confOverlay) {
    xfer += oprot->writeFieldBegin("confOverlay", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->confOverlay.size()));
      std::map<std::string, std::string> ::const_iterator _iter199;
      for (_iter199 = this->confOverlay.begin(); _iter199 != this->confOverlay.end(); ++_iter199)
      {
        xfer += oprot->writeString(_iter199->first);
        xfer += oprot->writeString(_iter199->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.runAsync) {
    xfer += oprot->writeFieldBegin("runAsync", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->runAsync);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TExecuteStatementReq &a, TExecuteStatementReq &b) {
  using ::std::swap;
  swap(a.sessionHandle, b.sessionHandle);
  swap(a.statement, b.statement);
  swap(a.confOverlay, b.confOverlay);
  swap(a.runAsync, b.runAsync);
  swap(a.__isset, b.__isset);
}

TExecuteStatementReq::TExecuteStatementReq(const TExecuteStatementReq& other200) {
  sessionHandle = other200.sessionHandle;
  statement = other200.statement;
  confOverlay = other200.confOverlay;
  runAsync = other200.runAsync;
  __isset = other200.__isset;
}
TExecuteStatementReq& TExecuteStatementReq::operator=(const TExecuteStatementReq& other201) {
  sessionHandle = other201.sessionHandle;
  statement = other201.statement;
  confOverlay = other201.confOverlay;
  runAsync = other201.runAsync;
  __isset = other201.__isset;
  return *this;
}

TExecuteStatementResp::~TExecuteStatementResp() throw() {
}


void TExecuteStatementResp::__set_status(const TStatus& val) {
  this->status = val;
}

void TExecuteStatementResp::__set_operationHandle(const TOperationHandle& val) {
  this->operationHandle = val;
__isset.operationHandle = true;
}

const char* TExecuteStatementResp::ascii_fingerprint = "02A075A0FF88D3A172916D8F23C7B286";
const uint8_t TExecuteStatementResp::binary_fingerprint[16] = {0x02,0xA0,0x75,0xA0,0xFF,0x88,0xD3,0xA1,0x72,0x91,0x6D,0x8F,0x23,0xC7,0xB2,0x86};

uint32_t TExecuteStatementResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          this->__isset.operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TExecuteStatementResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TExecuteStatementResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.operationHandle) {
    xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->operationHandle.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TExecuteStatementResp &a, TExecuteStatementResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.operationHandle, b.operationHandle);
  swap(a.__isset, b.__isset);
}

TExecuteStatementResp::TExecuteStatementResp(const TExecuteStatementResp& other202) {
  status = other202.status;
  operationHandle = other202.operationHandle;
  __isset = other202.__isset;
}
TExecuteStatementResp& TExecuteStatementResp::operator=(const TExecuteStatementResp& other203) {
  status = other203.status;
  operationHandle = other203.operationHandle;
  __isset = other203.__isset;
  return *this;
}

TGetTypeInfoReq::~TGetTypeInfoReq() throw() {
}


void TGetTypeInfoReq::__set_sessionHandle(const TSessionHandle& val) {
  this->sessionHandle = val;
}

const char* TGetTypeInfoReq::ascii_fingerprint = "82377107F8BD0526960537D5A112E6EF";
const uint8_t TGetTypeInfoReq::binary_fingerprint[16] = {0x82,0x37,0x71,0x07,0xF8,0xBD,0x05,0x26,0x96,0x05,0x37,0xD5,0xA1,0x12,0xE6,0xEF};

uint32_t TGetTypeInfoReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionHandle = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          isset_sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetTypeInfoReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TGetTypeInfoReq");

  xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TGetTypeInfoReq &a, TGetTypeInfoReq &b) {
  using ::std::swap;
  swap(a.sessionHandle, b.sessionHandle);
}

TGetTypeInfoReq::TGetTypeInfoReq(const TGetTypeInfoReq& other204) {
  sessionHandle = other204.sessionHandle;
}
TGetTypeInfoReq& TGetTypeInfoReq::operator=(const TGetTypeInfoReq& other205) {
  sessionHandle = other205.sessionHandle;
  return *this;
}

TGetTypeInfoResp::~TGetTypeInfoResp() throw() {
}


void TGetTypeInfoResp::__set_status(const TStatus& val) {
  this->status = val;
}

void TGetTypeInfoResp::__set_operationHandle(const TOperationHandle& val) {
  this->operationHandle = val;
__isset.operationHandle = true;
}

const char* TGetTypeInfoResp::ascii_fingerprint = "02A075A0FF88D3A172916D8F23C7B286";
const uint8_t TGetTypeInfoResp::binary_fingerprint[16] = {0x02,0xA0,0x75,0xA0,0xFF,0x88,0xD3,0xA1,0x72,0x91,0x6D,0x8F,0x23,0xC7,0xB2,0x86};

uint32_t TGetTypeInfoResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          this->__isset.operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetTypeInfoResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TGetTypeInfoResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.operationHandle) {
    xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->operationHandle.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TGetTypeInfoResp &a, TGetTypeInfoResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.operationHandle, b.operationHandle);
  swap(a.__isset, b.__isset);
}

TGetTypeInfoResp::TGetTypeInfoResp(const TGetTypeInfoResp& other206) {
  status = other206.status;
  operationHandle = other206.operationHandle;
  __isset = other206.__isset;
}
TGetTypeInfoResp& TGetTypeInfoResp::operator=(const TGetTypeInfoResp& other207) {
  status = other207.status;
  operationHandle = other207.operationHandle;
  __isset = other207.__isset;
  return *this;
}

TGetCatalogsReq::~TGetCatalogsReq() throw() {
}


void TGetCatalogsReq::__set_sessionHandle(const TSessionHandle& val) {
  this->sessionHandle = val;
}

const char* TGetCatalogsReq::ascii_fingerprint = "82377107F8BD0526960537D5A112E6EF";
const uint8_t TGetCatalogsReq::binary_fingerprint[16] = {0x82,0x37,0x71,0x07,0xF8,0xBD,0x05,0x26,0x96,0x05,0x37,0xD5,0xA1,0x12,0xE6,0xEF};

uint32_t TGetCatalogsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionHandle = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          isset_sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetCatalogsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TGetCatalogsReq");

  xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TGetCatalogsReq &a, TGetCatalogsReq &b) {
  using ::std::swap;
  swap(a.sessionHandle, b.sessionHandle);
}

TGetCatalogsReq::TGetCatalogsReq(const TGetCatalogsReq& other208) {
  sessionHandle = other208.sessionHandle;
}
TGetCatalogsReq& TGetCatalogsReq::operator=(const TGetCatalogsReq& other209) {
  sessionHandle = other209.sessionHandle;
  return *this;
}

TGetCatalogsResp::~TGetCatalogsResp() throw() {
}


void TGetCatalogsResp::__set_status(const TStatus& val) {
  this->status = val;
}

void TGetCatalogsResp::__set_operationHandle(const TOperationHandle& val) {
  this->operationHandle = val;
__isset.operationHandle = true;
}

const char* TGetCatalogsResp::ascii_fingerprint = "02A075A0FF88D3A172916D8F23C7B286";
const uint8_t TGetCatalogsResp::binary_fingerprint[16] = {0x02,0xA0,0x75,0xA0,0xFF,0x88,0xD3,0xA1,0x72,0x91,0x6D,0x8F,0x23,0xC7,0xB2,0x86};

uint32_t TGetCatalogsResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          this->__isset.operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetCatalogsResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TGetCatalogsResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.operationHandle) {
    xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->operationHandle.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TGetCatalogsResp &a, TGetCatalogsResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.operationHandle, b.operationHandle);
  swap(a.__isset, b.__isset);
}

TGetCatalogsResp::TGetCatalogsResp(const TGetCatalogsResp& other210) {
  status = other210.status;
  operationHandle = other210.operationHandle;
  __isset = other210.__isset;
}
TGetCatalogsResp& TGetCatalogsResp::operator=(const TGetCatalogsResp& other211) {
  status = other211.status;
  operationHandle = other211.operationHandle;
  __isset = other211.__isset;
  return *this;
}

TGetSchemasReq::~TGetSchemasReq() throw() {
}


void TGetSchemasReq::__set_sessionHandle(const TSessionHandle& val) {
  this->sessionHandle = val;
}

void TGetSchemasReq::__set_catalogName(const TIdentifier& val) {
  this->catalogName = val;
__isset.catalogName = true;
}

void TGetSchemasReq::__set_schemaName(const TPatternOrIdentifier& val) {
  this->schemaName = val;
__isset.schemaName = true;
}

const char* TGetSchemasReq::ascii_fingerprint = "28A9D12DE8393DD3E73FC1E5AE6E113B";
const uint8_t TGetSchemasReq::binary_fingerprint[16] = {0x28,0xA9,0xD1,0x2D,0xE8,0x39,0x3D,0xD3,0xE7,0x3F,0xC1,0xE5,0xAE,0x6E,0x11,0x3B};

uint32_t TGetSchemasReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionHandle = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          isset_sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catalogName);
          this->__isset.catalogName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->schemaName);
          this->__isset.schemaName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetSchemasReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TGetSchemasReq");

  xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.catalogName) {
    xfer += oprot->writeFieldBegin("catalogName", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->catalogName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.schemaName) {
    xfer += oprot->writeFieldBegin("schemaName", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->schemaName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TGetSchemasReq &a, TGetSchemasReq &b) {
  using ::std::swap;
  swap(a.sessionHandle, b.sessionHandle);
  swap(a.catalogName, b.catalogName);
  swap(a.schemaName, b.schemaName);
  swap(a.__isset, b.__isset);
}

TGetSchemasReq::TGetSchemasReq(const TGetSchemasReq& other212) {
  sessionHandle = other212.sessionHandle;
  catalogName = other212.catalogName;
  schemaName = other212.schemaName;
  __isset = other212.__isset;
}
TGetSchemasReq& TGetSchemasReq::operator=(const TGetSchemasReq& other213) {
  sessionHandle = other213.sessionHandle;
  catalogName = other213.catalogName;
  schemaName = other213.schemaName;
  __isset = other213.__isset;
  return *this;
}

TGetSchemasResp::~TGetSchemasResp() throw() {
}


void TGetSchemasResp::__set_status(const TStatus& val) {
  this->status = val;
}

void TGetSchemasResp::__set_operationHandle(const TOperationHandle& val) {
  this->operationHandle = val;
__isset.operationHandle = true;
}

const char* TGetSchemasResp::ascii_fingerprint = "02A075A0FF88D3A172916D8F23C7B286";
const uint8_t TGetSchemasResp::binary_fingerprint[16] = {0x02,0xA0,0x75,0xA0,0xFF,0x88,0xD3,0xA1,0x72,0x91,0x6D,0x8F,0x23,0xC7,0xB2,0x86};

uint32_t TGetSchemasResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          this->__isset.operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetSchemasResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TGetSchemasResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.operationHandle) {
    xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->operationHandle.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TGetSchemasResp &a, TGetSchemasResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.operationHandle, b.operationHandle);
  swap(a.__isset, b.__isset);
}

TGetSchemasResp::TGetSchemasResp(const TGetSchemasResp& other214) {
  status = other214.status;
  operationHandle = other214.operationHandle;
  __isset = other214.__isset;
}
TGetSchemasResp& TGetSchemasResp::operator=(const TGetSchemasResp& other215) {
  status = other215.status;
  operationHandle = other215.operationHandle;
  __isset = other215.__isset;
  return *this;
}

TGetTablesReq::~TGetTablesReq() throw() {
}


void TGetTablesReq::__set_sessionHandle(const TSessionHandle& val) {
  this->sessionHandle = val;
}

void TGetTablesReq::__set_catalogName(const TPatternOrIdentifier& val) {
  this->catalogName = val;
__isset.catalogName = true;
}

void TGetTablesReq::__set_schemaName(const TPatternOrIdentifier& val) {
  this->schemaName = val;
__isset.schemaName = true;
}

void TGetTablesReq::__set_tableName(const TPatternOrIdentifier& val) {
  this->tableName = val;
__isset.tableName = true;
}

void TGetTablesReq::__set_tableTypes(const std::vector<std::string> & val) {
  this->tableTypes = val;
__isset.tableTypes = true;
}

const char* TGetTablesReq::ascii_fingerprint = "C80DFEE06850052F5A445BE81ED763DB";
const uint8_t TGetTablesReq::binary_fingerprint[16] = {0xC8,0x0D,0xFE,0xE0,0x68,0x50,0x05,0x2F,0x5A,0x44,0x5B,0xE8,0x1E,0xD7,0x63,0xDB};

uint32_t TGetTablesReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionHandle = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          isset_sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catalogName);
          this->__isset.catalogName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->schemaName);
          this->__isset.schemaName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tableTypes.clear();
            uint32_t _size216;
            ::apache::thrift::protocol::TType _etype219;
            xfer += iprot->readListBegin(_etype219, _size216);
            this->tableTypes.resize(_size216);
            uint32_t _i220;
            for (_i220 = 0; _i220 < _size216; ++_i220)
            {
              xfer += iprot->readString(this->tableTypes[_i220]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tableTypes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetTablesReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TGetTablesReq");

  xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.catalogName) {
    xfer += oprot->writeFieldBegin("catalogName", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->catalogName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.schemaName) {
    xfer += oprot->writeFieldBegin("schemaName", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->schemaName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tableName) {
    xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->tableName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tableTypes) {
    xfer += oprot->writeFieldBegin("tableTypes", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->tableTypes.size()));
      std::vector<std::string> ::const_iterator _iter221;
      for (_iter221 = this->tableTypes.begin(); _iter221 != this->tableTypes.end(); ++_iter221)
      {
        xfer += oprot->writeString((*_iter221));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TGetTablesReq &a, TGetTablesReq &b) {
  using ::std::swap;
  swap(a.sessionHandle, b.sessionHandle);
  swap(a.catalogName, b.catalogName);
  swap(a.schemaName, b.schemaName);
  swap(a.tableName, b.tableName);
  swap(a.tableTypes, b.tableTypes);
  swap(a.__isset, b.__isset);
}

TGetTablesReq::TGetTablesReq(const TGetTablesReq& other222) {
  sessionHandle = other222.sessionHandle;
  catalogName = other222.catalogName;
  schemaName = other222.schemaName;
  tableName = other222.tableName;
  tableTypes = other222.tableTypes;
  __isset = other222.__isset;
}
TGetTablesReq& TGetTablesReq::operator=(const TGetTablesReq& other223) {
  sessionHandle = other223.sessionHandle;
  catalogName = other223.catalogName;
  schemaName = other223.schemaName;
  tableName = other223.tableName;
  tableTypes = other223.tableTypes;
  __isset = other223.__isset;
  return *this;
}

TGetTablesResp::~TGetTablesResp() throw() {
}


void TGetTablesResp::__set_status(const TStatus& val) {
  this->status = val;
}

void TGetTablesResp::__set_operationHandle(const TOperationHandle& val) {
  this->operationHandle = val;
__isset.operationHandle = true;
}

const char* TGetTablesResp::ascii_fingerprint = "02A075A0FF88D3A172916D8F23C7B286";
const uint8_t TGetTablesResp::binary_fingerprint[16] = {0x02,0xA0,0x75,0xA0,0xFF,0x88,0xD3,0xA1,0x72,0x91,0x6D,0x8F,0x23,0xC7,0xB2,0x86};

uint32_t TGetTablesResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          this->__isset.operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetTablesResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TGetTablesResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.operationHandle) {
    xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->operationHandle.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TGetTablesResp &a, TGetTablesResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.operationHandle, b.operationHandle);
  swap(a.__isset, b.__isset);
}

TGetTablesResp::TGetTablesResp(const TGetTablesResp& other224) {
  status = other224.status;
  operationHandle = other224.operationHandle;
  __isset = other224.__isset;
}
TGetTablesResp& TGetTablesResp::operator=(const TGetTablesResp& other225) {
  status = other225.status;
  operationHandle = other225.operationHandle;
  __isset = other225.__isset;
  return *this;
}

TGetTableTypesReq::~TGetTableTypesReq() throw() {
}


void TGetTableTypesReq::__set_sessionHandle(const TSessionHandle& val) {
  this->sessionHandle = val;
}

const char* TGetTableTypesReq::ascii_fingerprint = "82377107F8BD0526960537D5A112E6EF";
const uint8_t TGetTableTypesReq::binary_fingerprint[16] = {0x82,0x37,0x71,0x07,0xF8,0xBD,0x05,0x26,0x96,0x05,0x37,0xD5,0xA1,0x12,0xE6,0xEF};

uint32_t TGetTableTypesReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionHandle = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          isset_sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetTableTypesReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TGetTableTypesReq");

  xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TGetTableTypesReq &a, TGetTableTypesReq &b) {
  using ::std::swap;
  swap(a.sessionHandle, b.sessionHandle);
}

TGetTableTypesReq::TGetTableTypesReq(const TGetTableTypesReq& other226) {
  sessionHandle = other226.sessionHandle;
}
TGetTableTypesReq& TGetTableTypesReq::operator=(const TGetTableTypesReq& other227) {
  sessionHandle = other227.sessionHandle;
  return *this;
}

TGetTableTypesResp::~TGetTableTypesResp() throw() {
}


void TGetTableTypesResp::__set_status(const TStatus& val) {
  this->status = val;
}

void TGetTableTypesResp::__set_operationHandle(const TOperationHandle& val) {
  this->operationHandle = val;
__isset.operationHandle = true;
}

const char* TGetTableTypesResp::ascii_fingerprint = "02A075A0FF88D3A172916D8F23C7B286";
const uint8_t TGetTableTypesResp::binary_fingerprint[16] = {0x02,0xA0,0x75,0xA0,0xFF,0x88,0xD3,0xA1,0x72,0x91,0x6D,0x8F,0x23,0xC7,0xB2,0x86};

uint32_t TGetTableTypesResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          this->__isset.operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetTableTypesResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TGetTableTypesResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.operationHandle) {
    xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->operationHandle.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TGetTableTypesResp &a, TGetTableTypesResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.operationHandle, b.operationHandle);
  swap(a.__isset, b.__isset);
}

TGetTableTypesResp::TGetTableTypesResp(const TGetTableTypesResp& other228) {
  status = other228.status;
  operationHandle = other228.operationHandle;
  __isset = other228.__isset;
}
TGetTableTypesResp& TGetTableTypesResp::operator=(const TGetTableTypesResp& other229) {
  status = other229.status;
  operationHandle = other229.operationHandle;
  __isset = other229.__isset;
  return *this;
}

TGetColumnsReq::~TGetColumnsReq() throw() {
}


void TGetColumnsReq::__set_sessionHandle(const TSessionHandle& val) {
  this->sessionHandle = val;
}

void TGetColumnsReq::__set_catalogName(const TIdentifier& val) {
  this->catalogName = val;
__isset.catalogName = true;
}

void TGetColumnsReq::__set_schemaName(const TPatternOrIdentifier& val) {
  this->schemaName = val;
__isset.schemaName = true;
}

void TGetColumnsReq::__set_tableName(const TPatternOrIdentifier& val) {
  this->tableName = val;
__isset.tableName = true;
}

void TGetColumnsReq::__set_columnName(const TPatternOrIdentifier& val) {
  this->columnName = val;
__isset.columnName = true;
}

const char* TGetColumnsReq::ascii_fingerprint = "72D0F28ED33A49B7306DF63EEE956C28";
const uint8_t TGetColumnsReq::binary_fingerprint[16] = {0x72,0xD0,0xF2,0x8E,0xD3,0x3A,0x49,0xB7,0x30,0x6D,0xF6,0x3E,0xEE,0x95,0x6C,0x28};

uint32_t TGetColumnsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionHandle = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          isset_sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catalogName);
          this->__isset.catalogName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->schemaName);
          this->__isset.schemaName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->columnName);
          this->__isset.columnName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetColumnsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TGetColumnsReq");

  xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.catalogName) {
    xfer += oprot->writeFieldBegin("catalogName", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->catalogName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.schemaName) {
    xfer += oprot->writeFieldBegin("schemaName", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->schemaName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tableName) {
    xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->tableName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.columnName) {
    xfer += oprot->writeFieldBegin("columnName", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->columnName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TGetColumnsReq &a, TGetColumnsReq &b) {
  using ::std::swap;
  swap(a.sessionHandle, b.sessionHandle);
  swap(a.catalogName, b.catalogName);
  swap(a.schemaName, b.schemaName);
  swap(a.tableName, b.tableName);
  swap(a.columnName, b.columnName);
  swap(a.__isset, b.__isset);
}

TGetColumnsReq::TGetColumnsReq(const TGetColumnsReq& other230) {
  sessionHandle = other230.sessionHandle;
  catalogName = other230.catalogName;
  schemaName = other230.schemaName;
  tableName = other230.tableName;
  columnName = other230.columnName;
  __isset = other230.__isset;
}
TGetColumnsReq& TGetColumnsReq::operator=(const TGetColumnsReq& other231) {
  sessionHandle = other231.sessionHandle;
  catalogName = other231.catalogName;
  schemaName = other231.schemaName;
  tableName = other231.tableName;
  columnName = other231.columnName;
  __isset = other231.__isset;
  return *this;
}

TGetColumnsResp::~TGetColumnsResp() throw() {
}


void TGetColumnsResp::__set_status(const TStatus& val) {
  this->status = val;
}

void TGetColumnsResp::__set_operationHandle(const TOperationHandle& val) {
  this->operationHandle = val;
__isset.operationHandle = true;
}

const char* TGetColumnsResp::ascii_fingerprint = "02A075A0FF88D3A172916D8F23C7B286";
const uint8_t TGetColumnsResp::binary_fingerprint[16] = {0x02,0xA0,0x75,0xA0,0xFF,0x88,0xD3,0xA1,0x72,0x91,0x6D,0x8F,0x23,0xC7,0xB2,0x86};

uint32_t TGetColumnsResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          this->__isset.operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetColumnsResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TGetColumnsResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.operationHandle) {
    xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->operationHandle.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TGetColumnsResp &a, TGetColumnsResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.operationHandle, b.operationHandle);
  swap(a.__isset, b.__isset);
}

TGetColumnsResp::TGetColumnsResp(const TGetColumnsResp& other232) {
  status = other232.status;
  operationHandle = other232.operationHandle;
  __isset = other232.__isset;
}
TGetColumnsResp& TGetColumnsResp::operator=(const TGetColumnsResp& other233) {
  status = other233.status;
  operationHandle = other233.operationHandle;
  __isset = other233.__isset;
  return *this;
}

TGetFunctionsReq::~TGetFunctionsReq() throw() {
}


void TGetFunctionsReq::__set_sessionHandle(const TSessionHandle& val) {
  this->sessionHandle = val;
}

void TGetFunctionsReq::__set_catalogName(const TIdentifier& val) {
  this->catalogName = val;
__isset.catalogName = true;
}

void TGetFunctionsReq::__set_schemaName(const TPatternOrIdentifier& val) {
  this->schemaName = val;
__isset.schemaName = true;
}

void TGetFunctionsReq::__set_functionName(const TPatternOrIdentifier& val) {
  this->functionName = val;
}

const char* TGetFunctionsReq::ascii_fingerprint = "0887E0916ADE4521BF6017B534493138";
const uint8_t TGetFunctionsReq::binary_fingerprint[16] = {0x08,0x87,0xE0,0x91,0x6A,0xDE,0x45,0x21,0xBF,0x60,0x17,0xB5,0x34,0x49,0x31,0x38};

uint32_t TGetFunctionsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionHandle = false;
  bool isset_functionName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          isset_sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catalogName);
          this->__isset.catalogName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->schemaName);
          this->__isset.schemaName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->functionName);
          isset_functionName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_functionName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetFunctionsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TGetFunctionsReq");

  xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.catalogName) {
    xfer += oprot->writeFieldBegin("catalogName", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->catalogName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.schemaName) {
    xfer += oprot->writeFieldBegin("schemaName", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->schemaName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("functionName", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->functionName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TGetFunctionsReq &a, TGetFunctionsReq &b) {
  using ::std::swap;
  swap(a.sessionHandle, b.sessionHandle);
  swap(a.catalogName, b.catalogName);
  swap(a.schemaName, b.schemaName);
  swap(a.functionName, b.functionName);
  swap(a.__isset, b.__isset);
}

TGetFunctionsReq::TGetFunctionsReq(const TGetFunctionsReq& other234) {
  sessionHandle = other234.sessionHandle;
  catalogName = other234.catalogName;
  schemaName = other234.schemaName;
  functionName = other234.functionName;
  __isset = other234.__isset;
}
TGetFunctionsReq& TGetFunctionsReq::operator=(const TGetFunctionsReq& other235) {
  sessionHandle = other235.sessionHandle;
  catalogName = other235.catalogName;
  schemaName = other235.schemaName;
  functionName = other235.functionName;
  __isset = other235.__isset;
  return *this;
}

TGetFunctionsResp::~TGetFunctionsResp() throw() {
}


void TGetFunctionsResp::__set_status(const TStatus& val) {
  this->status = val;
}

void TGetFunctionsResp::__set_operationHandle(const TOperationHandle& val) {
  this->operationHandle = val;
__isset.operationHandle = true;
}

const char* TGetFunctionsResp::ascii_fingerprint = "02A075A0FF88D3A172916D8F23C7B286";
const uint8_t TGetFunctionsResp::binary_fingerprint[16] = {0x02,0xA0,0x75,0xA0,0xFF,0x88,0xD3,0xA1,0x72,0x91,0x6D,0x8F,0x23,0xC7,0xB2,0x86};

uint32_t TGetFunctionsResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          this->__isset.operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetFunctionsResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TGetFunctionsResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.operationHandle) {
    xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->operationHandle.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TGetFunctionsResp &a, TGetFunctionsResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.operationHandle, b.operationHandle);
  swap(a.__isset, b.__isset);
}

TGetFunctionsResp::TGetFunctionsResp(const TGetFunctionsResp& other236) {
  status = other236.status;
  operationHandle = other236.operationHandle;
  __isset = other236.__isset;
}
TGetFunctionsResp& TGetFunctionsResp::operator=(const TGetFunctionsResp& other237) {
  status = other237.status;
  operationHandle = other237.operationHandle;
  __isset = other237.__isset;
  return *this;
}

TGetOperationStatusReq::~TGetOperationStatusReq() throw() {
}


void TGetOperationStatusReq::__set_operationHandle(const TOperationHandle& val) {
  this->operationHandle = val;
}

const char* TGetOperationStatusReq::ascii_fingerprint = "414FA38522AE6B9CEC1438B56CA1DE5A";
const uint8_t TGetOperationStatusReq::binary_fingerprint[16] = {0x41,0x4F,0xA3,0x85,0x22,0xAE,0x6B,0x9C,0xEC,0x14,0x38,0xB5,0x6C,0xA1,0xDE,0x5A};

uint32_t TGetOperationStatusReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_operationHandle = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          isset_operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_operationHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetOperationStatusReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TGetOperationStatusReq");

  xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->operationHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TGetOperationStatusReq &a, TGetOperationStatusReq &b) {
  using ::std::swap;
  swap(a.operationHandle, b.operationHandle);
}

TGetOperationStatusReq::TGetOperationStatusReq(const TGetOperationStatusReq& other238) {
  operationHandle = other238.operationHandle;
}
TGetOperationStatusReq& TGetOperationStatusReq::operator=(const TGetOperationStatusReq& other239) {
  operationHandle = other239.operationHandle;
  return *this;
}

TGetOperationStatusResp::~TGetOperationStatusResp() throw() {
}


void TGetOperationStatusResp::__set_status(const TStatus& val) {
  this->status = val;
}

void TGetOperationStatusResp::__set_operationState(const TOperationState::type val) {
  this->operationState = val;
__isset.operationState = true;
}

void TGetOperationStatusResp::__set_sqlState(const std::string& val) {
  this->sqlState = val;
__isset.sqlState = true;
}

void TGetOperationStatusResp::__set_errorCode(const int32_t val) {
  this->errorCode = val;
__isset.errorCode = true;
}

void TGetOperationStatusResp::__set_errorMessage(const std::string& val) {
  this->errorMessage = val;
__isset.errorMessage = true;
}

const char* TGetOperationStatusResp::ascii_fingerprint = "BD124DB87A5A2E7D11945BD1B17F013D";
const uint8_t TGetOperationStatusResp::binary_fingerprint[16] = {0xBD,0x12,0x4D,0xB8,0x7A,0x5A,0x2E,0x7D,0x11,0x94,0x5B,0xD1,0xB1,0x7F,0x01,0x3D};

uint32_t TGetOperationStatusResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast240;
          xfer += iprot->readI32(ecast240);
          this->operationState = (TOperationState::type)ecast240;
          this->__isset.operationState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sqlState);
          this->__isset.sqlState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->errorCode);
          this->__isset.errorCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->errorMessage);
          this->__isset.errorMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetOperationStatusResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TGetOperationStatusResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.operationState) {
    xfer += oprot->writeFieldBegin("operationState", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32((int32_t)this->operationState);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sqlState) {
    xfer += oprot->writeFieldBegin("sqlState", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->sqlState);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.errorCode) {
    xfer += oprot->writeFieldBegin("errorCode", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->errorCode);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.errorMessage) {
    xfer += oprot->writeFieldBegin("errorMessage", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->errorMessage);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TGetOperationStatusResp &a, TGetOperationStatusResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.operationState, b.operationState);
  swap(a.sqlState, b.sqlState);
  swap(a.errorCode, b.errorCode);
  swap(a.errorMessage, b.errorMessage);
  swap(a.__isset, b.__isset);
}

TGetOperationStatusResp::TGetOperationStatusResp(const TGetOperationStatusResp& other241) {
  status = other241.status;
  operationState = other241.operationState;
  sqlState = other241.sqlState;
  errorCode = other241.errorCode;
  errorMessage = other241.errorMessage;
  __isset = other241.__isset;
}
TGetOperationStatusResp& TGetOperationStatusResp::operator=(const TGetOperationStatusResp& other242) {
  status = other242.status;
  operationState = other242.operationState;
  sqlState = other242.sqlState;
  errorCode = other242.errorCode;
  errorMessage = other242.errorMessage;
  __isset = other242.__isset;
  return *this;
}

TCancelOperationReq::~TCancelOperationReq() throw() {
}


void TCancelOperationReq::__set_operationHandle(const TOperationHandle& val) {
  this->operationHandle = val;
}

const char* TCancelOperationReq::ascii_fingerprint = "414FA38522AE6B9CEC1438B56CA1DE5A";
const uint8_t TCancelOperationReq::binary_fingerprint[16] = {0x41,0x4F,0xA3,0x85,0x22,0xAE,0x6B,0x9C,0xEC,0x14,0x38,0xB5,0x6C,0xA1,0xDE,0x5A};

uint32_t TCancelOperationReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_operationHandle = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          isset_operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_operationHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCancelOperationReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TCancelOperationReq");

  xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->operationHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TCancelOperationReq &a, TCancelOperationReq &b) {
  using ::std::swap;
  swap(a.operationHandle, b.operationHandle);
}

TCancelOperationReq::TCancelOperationReq(const TCancelOperationReq& other243) {
  operationHandle = other243.operationHandle;
}
TCancelOperationReq& TCancelOperationReq::operator=(const TCancelOperationReq& other244) {
  operationHandle = other244.operationHandle;
  return *this;
}

TCancelOperationResp::~TCancelOperationResp() throw() {
}


void TCancelOperationResp::__set_status(const TStatus& val) {
  this->status = val;
}

const char* TCancelOperationResp::ascii_fingerprint = "7142E89F09DC7C5F6FA916C7393F46C2";
const uint8_t TCancelOperationResp::binary_fingerprint[16] = {0x71,0x42,0xE8,0x9F,0x09,0xDC,0x7C,0x5F,0x6F,0xA9,0x16,0xC7,0x39,0x3F,0x46,0xC2};

uint32_t TCancelOperationResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCancelOperationResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TCancelOperationResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TCancelOperationResp &a, TCancelOperationResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
}

TCancelOperationResp::TCancelOperationResp(const TCancelOperationResp& other245) {
  status = other245.status;
}
TCancelOperationResp& TCancelOperationResp::operator=(const TCancelOperationResp& other246) {
  status = other246.status;
  return *this;
}

TCloseOperationReq::~TCloseOperationReq() throw() {
}


void TCloseOperationReq::__set_operationHandle(const TOperationHandle& val) {
  this->operationHandle = val;
}

const char* TCloseOperationReq::ascii_fingerprint = "414FA38522AE6B9CEC1438B56CA1DE5A";
const uint8_t TCloseOperationReq::binary_fingerprint[16] = {0x41,0x4F,0xA3,0x85,0x22,0xAE,0x6B,0x9C,0xEC,0x14,0x38,0xB5,0x6C,0xA1,0xDE,0x5A};

uint32_t TCloseOperationReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_operationHandle = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          isset_operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_operationHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCloseOperationReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TCloseOperationReq");

  xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->operationHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TCloseOperationReq &a, TCloseOperationReq &b) {
  using ::std::swap;
  swap(a.operationHandle, b.operationHandle);
}

TCloseOperationReq::TCloseOperationReq(const TCloseOperationReq& other247) {
  operationHandle = other247.operationHandle;
}
TCloseOperationReq& TCloseOperationReq::operator=(const TCloseOperationReq& other248) {
  operationHandle = other248.operationHandle;
  return *this;
}

TCloseOperationResp::~TCloseOperationResp() throw() {
}


void TCloseOperationResp::__set_status(const TStatus& val) {
  this->status = val;
}

const char* TCloseOperationResp::ascii_fingerprint = "7142E89F09DC7C5F6FA916C7393F46C2";
const uint8_t TCloseOperationResp::binary_fingerprint[16] = {0x71,0x42,0xE8,0x9F,0x09,0xDC,0x7C,0x5F,0x6F,0xA9,0x16,0xC7,0x39,0x3F,0x46,0xC2};

uint32_t TCloseOperationResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCloseOperationResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TCloseOperationResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TCloseOperationResp &a, TCloseOperationResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
}

TCloseOperationResp::TCloseOperationResp(const TCloseOperationResp& other249) {
  status = other249.status;
}
TCloseOperationResp& TCloseOperationResp::operator=(const TCloseOperationResp& other250) {
  status = other250.status;
  return *this;
}

TGetResultSetMetadataReq::~TGetResultSetMetadataReq() throw() {
}


void TGetResultSetMetadataReq::__set_operationHandle(const TOperationHandle& val) {
  this->operationHandle = val;
}

const char* TGetResultSetMetadataReq::ascii_fingerprint = "414FA38522AE6B9CEC1438B56CA1DE5A";
const uint8_t TGetResultSetMetadataReq::binary_fingerprint[16] = {0x41,0x4F,0xA3,0x85,0x22,0xAE,0x6B,0x9C,0xEC,0x14,0x38,0xB5,0x6C,0xA1,0xDE,0x5A};

uint32_t TGetResultSetMetadataReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_operationHandle = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          isset_operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_operationHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetResultSetMetadataReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TGetResultSetMetadataReq");

  xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->operationHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TGetResultSetMetadataReq &a, TGetResultSetMetadataReq &b) {
  using ::std::swap;
  swap(a.operationHandle, b.operationHandle);
}

TGetResultSetMetadataReq::TGetResultSetMetadataReq(const TGetResultSetMetadataReq& other251) {
  operationHandle = other251.operationHandle;
}
TGetResultSetMetadataReq& TGetResultSetMetadataReq::operator=(const TGetResultSetMetadataReq& other252) {
  operationHandle = other252.operationHandle;
  return *this;
}

TGetResultSetMetadataResp::~TGetResultSetMetadataResp() throw() {
}


void TGetResultSetMetadataResp::__set_status(const TStatus& val) {
  this->status = val;
}

void TGetResultSetMetadataResp::__set_schema(const TTableSchema& val) {
  this->schema = val;
__isset.schema = true;
}

const char* TGetResultSetMetadataResp::ascii_fingerprint = "42CD49B7F49CC1B6D4E6F5FA2D7BE812";
const uint8_t TGetResultSetMetadataResp::binary_fingerprint[16] = {0x42,0xCD,0x49,0xB7,0xF4,0x9C,0xC1,0xB6,0xD4,0xE6,0xF5,0xFA,0x2D,0x7B,0xE8,0x12};

uint32_t TGetResultSetMetadataResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->schema.read(iprot);
          this->__isset.schema = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetResultSetMetadataResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TGetResultSetMetadataResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.schema) {
    xfer += oprot->writeFieldBegin("schema", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->schema.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TGetResultSetMetadataResp &a, TGetResultSetMetadataResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.schema, b.schema);
  swap(a.__isset, b.__isset);
}

TGetResultSetMetadataResp::TGetResultSetMetadataResp(const TGetResultSetMetadataResp& other253) {
  status = other253.status;
  schema = other253.schema;
  __isset = other253.__isset;
}
TGetResultSetMetadataResp& TGetResultSetMetadataResp::operator=(const TGetResultSetMetadataResp& other254) {
  status = other254.status;
  schema = other254.schema;
  __isset = other254.__isset;
  return *this;
}

TFetchResultsReq::~TFetchResultsReq() throw() {
}


void TFetchResultsReq::__set_operationHandle(const TOperationHandle& val) {
  this->operationHandle = val;
}

void TFetchResultsReq::__set_orientation(const TFetchOrientation::type val) {
  this->orientation = val;
}

void TFetchResultsReq::__set_maxRows(const int64_t val) {
  this->maxRows = val;
}

void TFetchResultsReq::__set_fetchType(const int16_t val) {
  this->fetchType = val;
__isset.fetchType = true;
}

const char* TFetchResultsReq::ascii_fingerprint = "B4CB1E4F8F8F4D50183DD372AD11753A";
const uint8_t TFetchResultsReq::binary_fingerprint[16] = {0xB4,0xCB,0x1E,0x4F,0x8F,0x8F,0x4D,0x50,0x18,0x3D,0xD3,0x72,0xAD,0x11,0x75,0x3A};

uint32_t TFetchResultsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_operationHandle = false;
  bool isset_orientation = false;
  bool isset_maxRows = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          isset_operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast255;
          xfer += iprot->readI32(ecast255);
          this->orientation = (TFetchOrientation::type)ecast255;
          isset_orientation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->maxRows);
          isset_maxRows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->fetchType);
          this->__isset.fetchType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_operationHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_orientation)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxRows)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TFetchResultsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TFetchResultsReq");

  xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->operationHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("orientation", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->orientation);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxRows", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->maxRows);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.fetchType) {
    xfer += oprot->writeFieldBegin("fetchType", ::apache::thrift::protocol::T_I16, 4);
    xfer += oprot->writeI16(this->fetchType);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TFetchResultsReq &a, TFetchResultsReq &b) {
  using ::std::swap;
  swap(a.operationHandle, b.operationHandle);
  swap(a.orientation, b.orientation);
  swap(a.maxRows, b.maxRows);
  swap(a.fetchType, b.fetchType);
  swap(a.__isset, b.__isset);
}

TFetchResultsReq::TFetchResultsReq(const TFetchResultsReq& other256) {
  operationHandle = other256.operationHandle;
  orientation = other256.orientation;
  maxRows = other256.maxRows;
  fetchType = other256.fetchType;
  __isset = other256.__isset;
}
TFetchResultsReq& TFetchResultsReq::operator=(const TFetchResultsReq& other257) {
  operationHandle = other257.operationHandle;
  orientation = other257.orientation;
  maxRows = other257.maxRows;
  fetchType = other257.fetchType;
  __isset = other257.__isset;
  return *this;
}

TFetchResultsResp::~TFetchResultsResp() throw() {
}


void TFetchResultsResp::__set_status(const TStatus& val) {
  this->status = val;
}

void TFetchResultsResp::__set_hasMoreRows(const bool val) {
  this->hasMoreRows = val;
__isset.hasMoreRows = true;
}

void TFetchResultsResp::__set_results(const TRowSet& val) {
  this->results = val;
__isset.results = true;
}

const char* TFetchResultsResp::ascii_fingerprint = "29891EA4D71B4283E8715DA5B95F2763";
const uint8_t TFetchResultsResp::binary_fingerprint[16] = {0x29,0x89,0x1E,0xA4,0xD7,0x1B,0x42,0x83,0xE8,0x71,0x5D,0xA5,0xB9,0x5F,0x27,0x63};

uint32_t TFetchResultsResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->hasMoreRows);
          this->__isset.hasMoreRows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->results.read(iprot);
          this->__isset.results = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TFetchResultsResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TFetchResultsResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.hasMoreRows) {
    xfer += oprot->writeFieldBegin("hasMoreRows", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->hasMoreRows);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.results) {
    xfer += oprot->writeFieldBegin("results", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->results.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TFetchResultsResp &a, TFetchResultsResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.hasMoreRows, b.hasMoreRows);
  swap(a.results, b.results);
  swap(a.__isset, b.__isset);
}

TFetchResultsResp::TFetchResultsResp(const TFetchResultsResp& other258) {
  status = other258.status;
  hasMoreRows = other258.hasMoreRows;
  results = other258.results;
  __isset = other258.__isset;
}
TFetchResultsResp& TFetchResultsResp::operator=(const TFetchResultsResp& other259) {
  status = other259.status;
  hasMoreRows = other259.hasMoreRows;
  results = other259.results;
  __isset = other259.__isset;
  return *this;
}

TGetDelegationTokenReq::~TGetDelegationTokenReq() throw() {
}


void TGetDelegationTokenReq::__set_sessionHandle(const TSessionHandle& val) {
  this->sessionHandle = val;
}

void TGetDelegationTokenReq::__set_owner(const std::string& val) {
  this->owner = val;
}

void TGetDelegationTokenReq::__set_renewer(const std::string& val) {
  this->renewer = val;
}

const char* TGetDelegationTokenReq::ascii_fingerprint = "07EA0311716A27924914E4354ED22D6C";
const uint8_t TGetDelegationTokenReq::binary_fingerprint[16] = {0x07,0xEA,0x03,0x11,0x71,0x6A,0x27,0x92,0x49,0x14,0xE4,0x35,0x4E,0xD2,0x2D,0x6C};

uint32_t TGetDelegationTokenReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionHandle = false;
  bool isset_owner = false;
  bool isset_renewer = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          isset_sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->owner);
          isset_owner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->renewer);
          isset_renewer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_owner)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_renewer)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetDelegationTokenReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TGetDelegationTokenReq");

  xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("owner", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->owner);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("renewer", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->renewer);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TGetDelegationTokenReq &a, TGetDelegationTokenReq &b) {
  using ::std::swap;
  swap(a.sessionHandle, b.sessionHandle);
  swap(a.owner, b.owner);
  swap(a.renewer, b.renewer);
}

TGetDelegationTokenReq::TGetDelegationTokenReq(const TGetDelegationTokenReq& other260) {
  sessionHandle = other260.sessionHandle;
  owner = other260.owner;
  renewer = other260.renewer;
}
TGetDelegationTokenReq& TGetDelegationTokenReq::operator=(const TGetDelegationTokenReq& other261) {
  sessionHandle = other261.sessionHandle;
  owner = other261.owner;
  renewer = other261.renewer;
  return *this;
}

TGetDelegationTokenResp::~TGetDelegationTokenResp() throw() {
}


void TGetDelegationTokenResp::__set_status(const TStatus& val) {
  this->status = val;
}

void TGetDelegationTokenResp::__set_delegationToken(const std::string& val) {
  this->delegationToken = val;
__isset.delegationToken = true;
}

const char* TGetDelegationTokenResp::ascii_fingerprint = "C0E132DC412CEA08D771EAC38CEA1DA6";
const uint8_t TGetDelegationTokenResp::binary_fingerprint[16] = {0xC0,0xE1,0x32,0xDC,0x41,0x2C,0xEA,0x08,0xD7,0x71,0xEA,0xC3,0x8C,0xEA,0x1D,0xA6};

uint32_t TGetDelegationTokenResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->delegationToken);
          this->__isset.delegationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetDelegationTokenResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TGetDelegationTokenResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.delegationToken) {
    xfer += oprot->writeFieldBegin("delegationToken", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->delegationToken);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TGetDelegationTokenResp &a, TGetDelegationTokenResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.delegationToken, b.delegationToken);
  swap(a.__isset, b.__isset);
}

TGetDelegationTokenResp::TGetDelegationTokenResp(const TGetDelegationTokenResp& other262) {
  status = other262.status;
  delegationToken = other262.delegationToken;
  __isset = other262.__isset;
}
TGetDelegationTokenResp& TGetDelegationTokenResp::operator=(const TGetDelegationTokenResp& other263) {
  status = other263.status;
  delegationToken = other263.delegationToken;
  __isset = other263.__isset;
  return *this;
}

TCancelDelegationTokenReq::~TCancelDelegationTokenReq() throw() {
}


void TCancelDelegationTokenReq::__set_sessionHandle(const TSessionHandle& val) {
  this->sessionHandle = val;
}

void TCancelDelegationTokenReq::__set_delegationToken(const std::string& val) {
  this->delegationToken = val;
}

const char* TCancelDelegationTokenReq::ascii_fingerprint = "1A3D66269336B7EC66998BFE1BECDE75";
const uint8_t TCancelDelegationTokenReq::binary_fingerprint[16] = {0x1A,0x3D,0x66,0x26,0x93,0x36,0xB7,0xEC,0x66,0x99,0x8B,0xFE,0x1B,0xEC,0xDE,0x75};

uint32_t TCancelDelegationTokenReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionHandle = false;
  bool isset_delegationToken = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          isset_sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->delegationToken);
          isset_delegationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_delegationToken)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCancelDelegationTokenReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TCancelDelegationTokenReq");

  xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("delegationToken", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->delegationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TCancelDelegationTokenReq &a, TCancelDelegationTokenReq &b) {
  using ::std::swap;
  swap(a.sessionHandle, b.sessionHandle);
  swap(a.delegationToken, b.delegationToken);
}

TCancelDelegationTokenReq::TCancelDelegationTokenReq(const TCancelDelegationTokenReq& other264) {
  sessionHandle = other264.sessionHandle;
  delegationToken = other264.delegationToken;
}
TCancelDelegationTokenReq& TCancelDelegationTokenReq::operator=(const TCancelDelegationTokenReq& other265) {
  sessionHandle = other265.sessionHandle;
  delegationToken = other265.delegationToken;
  return *this;
}

TCancelDelegationTokenResp::~TCancelDelegationTokenResp() throw() {
}


void TCancelDelegationTokenResp::__set_status(const TStatus& val) {
  this->status = val;
}

const char* TCancelDelegationTokenResp::ascii_fingerprint = "7142E89F09DC7C5F6FA916C7393F46C2";
const uint8_t TCancelDelegationTokenResp::binary_fingerprint[16] = {0x71,0x42,0xE8,0x9F,0x09,0xDC,0x7C,0x5F,0x6F,0xA9,0x16,0xC7,0x39,0x3F,0x46,0xC2};

uint32_t TCancelDelegationTokenResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCancelDelegationTokenResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TCancelDelegationTokenResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TCancelDelegationTokenResp &a, TCancelDelegationTokenResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
}

TCancelDelegationTokenResp::TCancelDelegationTokenResp(const TCancelDelegationTokenResp& other266) {
  status = other266.status;
}
TCancelDelegationTokenResp& TCancelDelegationTokenResp::operator=(const TCancelDelegationTokenResp& other267) {
  status = other267.status;
  return *this;
}

TRenewDelegationTokenReq::~TRenewDelegationTokenReq() throw() {
}


void TRenewDelegationTokenReq::__set_sessionHandle(const TSessionHandle& val) {
  this->sessionHandle = val;
}

void TRenewDelegationTokenReq::__set_delegationToken(const std::string& val) {
  this->delegationToken = val;
}

const char* TRenewDelegationTokenReq::ascii_fingerprint = "1A3D66269336B7EC66998BFE1BECDE75";
const uint8_t TRenewDelegationTokenReq::binary_fingerprint[16] = {0x1A,0x3D,0x66,0x26,0x93,0x36,0xB7,0xEC,0x66,0x99,0x8B,0xFE,0x1B,0xEC,0xDE,0x75};

uint32_t TRenewDelegationTokenReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionHandle = false;
  bool isset_delegationToken = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          isset_sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->delegationToken);
          isset_delegationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_delegationToken)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TRenewDelegationTokenReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TRenewDelegationTokenReq");

  xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("delegationToken", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->delegationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TRenewDelegationTokenReq &a, TRenewDelegationTokenReq &b) {
  using ::std::swap;
  swap(a.sessionHandle, b.sessionHandle);
  swap(a.delegationToken, b.delegationToken);
}

TRenewDelegationTokenReq::TRenewDelegationTokenReq(const TRenewDelegationTokenReq& other268) {
  sessionHandle = other268.sessionHandle;
  delegationToken = other268.delegationToken;
}
TRenewDelegationTokenReq& TRenewDelegationTokenReq::operator=(const TRenewDelegationTokenReq& other269) {
  sessionHandle = other269.sessionHandle;
  delegationToken = other269.delegationToken;
  return *this;
}

TRenewDelegationTokenResp::~TRenewDelegationTokenResp() throw() {
}


void TRenewDelegationTokenResp::__set_status(const TStatus& val) {
  this->status = val;
}

const char* TRenewDelegationTokenResp::ascii_fingerprint = "7142E89F09DC7C5F6FA916C7393F46C2";
const uint8_t TRenewDelegationTokenResp::binary_fingerprint[16] = {0x71,0x42,0xE8,0x9F,0x09,0xDC,0x7C,0x5F,0x6F,0xA9,0x16,0xC7,0x39,0x3F,0x46,0xC2};

uint32_t TRenewDelegationTokenResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TRenewDelegationTokenResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TRenewDelegationTokenResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TRenewDelegationTokenResp &a, TRenewDelegationTokenResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
}

TRenewDelegationTokenResp::TRenewDelegationTokenResp(const TRenewDelegationTokenResp& other270) {
  status = other270.status;
}
TRenewDelegationTokenResp& TRenewDelegationTokenResp::operator=(const TRenewDelegationTokenResp& other271) {
  status = other271.status;
  return *this;
}

TGetLogReq::~TGetLogReq() throw() {
}


void TGetLogReq::__set_operationHandle(const TOperationHandle& val) {
  this->operationHandle = val;
}

const char* TGetLogReq::ascii_fingerprint = "414FA38522AE6B9CEC1438B56CA1DE5A";
const uint8_t TGetLogReq::binary_fingerprint[16] = {0x41,0x4F,0xA3,0x85,0x22,0xAE,0x6B,0x9C,0xEC,0x14,0x38,0xB5,0x6C,0xA1,0xDE,0x5A};

uint32_t TGetLogReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_operationHandle = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          isset_operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_operationHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetLogReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TGetLogReq");

  xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->operationHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TGetLogReq &a, TGetLogReq &b) {
  using ::std::swap;
  swap(a.operationHandle, b.operationHandle);
}

TGetLogReq::TGetLogReq(const TGetLogReq& other272) {
  operationHandle = other272.operationHandle;
}
TGetLogReq& TGetLogReq::operator=(const TGetLogReq& other273) {
  operationHandle = other273.operationHandle;
  return *this;
}

TGetLogResp::~TGetLogResp() throw() {
}


void TGetLogResp::__set_status(const TStatus& val) {
  this->status = val;
}

void TGetLogResp::__set_log(const std::string& val) {
  this->log = val;
}

const char* TGetLogResp::ascii_fingerprint = "08A7F68AF7400F358E5CF08185165CB7";
const uint8_t TGetLogResp::binary_fingerprint[16] = {0x08,0xA7,0xF6,0x8A,0xF7,0x40,0x0F,0x35,0x8E,0x5C,0xF0,0x81,0x85,0x16,0x5C,0xB7};

uint32_t TGetLogResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;
  bool isset_log = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->log);
          isset_log = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_log)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetLogResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TGetLogResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("log", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->log);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TGetLogResp &a, TGetLogResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.log, b.log);
}

TGetLogResp::TGetLogResp(const TGetLogResp& other274) {
  status = other274.status;
  log = other274.log;
}
TGetLogResp& TGetLogResp::operator=(const TGetLogResp& other275) {
  status = other275.status;
  log = other275.log;
  return *this;
}
}}}}} // namespace
